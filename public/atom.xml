<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Weshzhu Blogs</title>
  
  <subtitle>weshzhu</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://172.104.32.215/"/>
  <updated>2019-03-25T06:24:41.264Z</updated>
  <id>http://172.104.32.215/</id>
  
  <author>
    <name>Weshzhu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>合并两个有序数组——java实现</title>
    <link href="http://172.104.32.215/2019/03/25/algorithm-two-order-list-merge/"/>
    <id>http://172.104.32.215/2019/03/25/algorithm-two-order-list-merge/</id>
    <published>2019-03-25T14:03:49.000Z</published>
    <updated>2019-03-25T06:24:41.264Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @function 合并两个有序数组arr1[] arr2[]</span><br><span class="line"> * @author PC</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MergeOrderList &#123;</span><br><span class="line">public static void merge(int [] arr1,int [] arr2)&#123;</span><br><span class="line">int len1 = arr1.length;//数组1长度</span><br><span class="line">int len2 = arr2.length;//数组2长度</span><br><span class="line">int len = len1 + len2;//合并后数组长度</span><br><span class="line">int arr[] = new int[len];//合并后的数组</span><br><span class="line">int j = len1-1;</span><br><span class="line">int i = len2-1;</span><br><span class="line">len--;</span><br><span class="line">while(i&gt;=0&amp;&amp;j&gt;=0)&#123;//从后向前比较</span><br><span class="line">if(arr2[i]&gt;arr1[j])&#123;//将第二个数组的最后第i个元素放入arr中</span><br><span class="line">arr[len--] = arr2[i];</span><br><span class="line">i--;//“指针”后移一位</span><br><span class="line">&#125;else if(arr2[i]&lt;=arr1[j])&#123;//将第一个数组的最后第i个元素放入arr中</span><br><span class="line">arr[len--] = arr1[j];</span><br><span class="line">j--;//“指针”后移一位</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(i&gt;j)&#123;//将剩余的数组1或者数组2的元素全部追加到数组arr</span><br><span class="line">while(i&gt;=0)&#123;</span><br><span class="line">arr[len--] = arr2[i--];</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">while(j&gt;=0)&#123;</span><br><span class="line">arr[len--] = arr1[j--];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for (int k = 0; k &lt; arr.length; k++) &#123;</span><br><span class="line">System.out.print(arr[k]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int arr1[] = &#123;1,4,5,7,10,11,15&#125;;</span><br><span class="line">int arr2[] = &#123;2,3,6,8,9,13,14,17&#125;;</span><br><span class="line">merge(arr1,arr2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="常见算法" scheme="http://172.104.32.215/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://172.104.32.215/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Centos 安装 docker</title>
    <link href="http://172.104.32.215/2019/03/25/install-docker-yum/"/>
    <id>http://172.104.32.215/2019/03/25/install-docker-yum/</id>
    <published>2019-03-25T13:35:59.000Z</published>
    <updated>2019-03-25T05:37:02.708Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本教程适用于对docker入门新手，在学习docker时，安装部署docker是第一步，然后跟着教程一步一步练习。</p></blockquote><h4 id="移除旧版本docker"><a href="#移除旧版本docker" class="headerlink" title="移除旧版本docker"></a>移除旧版本docker</h4><p>卸载旧版本docker，如果未安装，可以跳过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ yum remove -y docker docker-client \</span><br><span class="line">   docker-client-latest  \</span><br><span class="line">   docker-common \</span><br><span class="line">   docker-latest \</span><br><span class="line">   docker-latest-logrotate \</span><br><span class="line">   docker-logrotate \</span><br><span class="line">   docker-selinux \</span><br><span class="line">   docker-engine-selinux \</span><br><span class="line">   docker-engine</span><br></pre></td></tr></table></figure></p><h4 id="安装依赖软件"><a href="#安装依赖软件" class="headerlink" title="安装依赖软件"></a>安装依赖软件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y yum-utils \</span><br><span class="line">    device-mapper-persistent-data \</span><br><span class="line">    lvm2</span><br></pre></td></tr></table></figure><h4 id="配置yum源为阿里云提供的yum源"><a href="#配置yum源为阿里云提供的yum源" class="headerlink" title="配置yum源为阿里云提供的yum源"></a>配置yum源为阿里云提供的yum源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><h4 id="查看该yum源提供的可用docker-ce版本"><a href="#查看该yum源提供的可用docker-ce版本" class="headerlink" title="查看该yum源提供的可用docker-ce版本"></a>查看该yum源提供的可用docker-ce版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ yum list docker-ce –showduplicates | sort -r</span><br><span class="line"></span><br><span class="line">docker-ce.x86_64            3:18.09.0-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            18.06.1.ce-3.el7                   docker-ce-stable </span><br><span class="line">docker-ce.x86_64            18.06.1.ce-3.el7                   @docker-ce-stable</span><br><span class="line">docker-ce.x86_64            18.06.0.ce-3.el7                   docker-ce-stable </span><br><span class="line">docker-ce.x86_64            18.03.1.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            18.03.0.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.12.1.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.12.0.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.09.1.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.09.0.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.06.2.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.06.1.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.06.0.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.03.3.ce-1.el7                   docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.03.2.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.03.1.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.03.0.ce-1.el7.centos            docker-ce-stable</span><br></pre></td></tr></table></figure><p> 查看可用docker-ce版本，根据需求，安装指定版本的docker-ce<br> 安装docker-ce 18.06版本</p><ul><li><p>安装docker-ce 18.06版本</p><p><code>$ yum install docker-ce-18.06.1.ce -y</code></p></li><li><p>启动docker</p><p><code>$ systemctl start docker</code></p></li><li><p>设置开机启动</p><p><code>$ systemctl enable docker</code></p></li><li><p>授权用户</p><p>将用户添加到docker组</p><p><code>$ sudo usermod -aG docker $USER</code></p></li></ul><ul><li><p>配置镜像仓库加速</p><p>配置镜像加速：使用aliyun提供的镜像加速</p><p>通过修改daemon配置文件/etc/docker/daemon.json来使用加速器</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkdir -p /etc/docker</span><br><span class="line">$ sudo tee /etc/docker/daemon.json &lt;&lt;-&apos;EOF&apos; &#123;</span><br><span class="line">    &quot;registry-mirrors&quot;:[&quot;https://xxxxxx.mirror.aliyuncs.com&quot;] &#125;</span><br><span class="line">  EOF</span><br></pre></td></tr></table></figure><p> 注意 <a href="https://xxxxxx.mirror.aliyuncs.com" target="_blank" rel="noopener">https://xxxxxx.mirror.aliyuncs.com</a> 需要注册阿里云申请镜像仓库<br> 如果没有，可以使用作者的：<a href="https://hjjs2fuv.mirror.aliyuncs.com" target="_blank" rel="noopener">https://hjjs2fuv.mirror.aliyuncs.com</a></p></li><li><p>重新加载docker service使其生效</p><p><code>$ systemctl daemon-reload</code></p><p><code>$ systemctl restart docker</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本教程适用于对docker入门新手，在学习docker时，安装部署docker是第一步，然后跟着教程一步一步练习。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;移除旧版本docker&quot;&gt;&lt;a href=&quot;#移除旧版本docker&quot; clas
      
    
    </summary>
    
      <category term="运维" scheme="http://172.104.32.215/categories/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="docker" scheme="http://172.104.32.215/categories/%E8%BF%90%E7%BB%B4/docker/"/>
    
    
      <category term="docker" scheme="http://172.104.32.215/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker网络驱动(network driver)之————网桥(bridge)</title>
    <link href="http://172.104.32.215/2019/03/25/docker-network-bridge/"/>
    <id>http://172.104.32.215/2019/03/25/docker-network-bridge/</id>
    <published>2019-03-25T13:33:15.000Z</published>
    <updated>2019-03-25T05:45:06.757Z</updated>
    
    <content type="html"><![CDATA[<p>Docker网络驱动(network driver)之————网桥(bridge)</p><blockquote><p>在《计算机网络》这本教材中，我们学习过，<strong>网桥</strong>是一种工作在数据链路层，对帧进行转发的技术，它根据MAC帧的目标地址对收到的帧进行转发和过滤。网桥可以是硬件设备也可以是在主机内核（kernel）中运行的软件设备。</p></blockquote><p>在Docker的网络系统中，<strong>网桥</strong><code>bridge network</code>是默认的网络驱动。使用软件桥接器，允许连接到同一桥接网络的<strong>容器</strong>之间进行通信，同时隔离那些未连接到该<strong>网桥</strong>的容器。当启动<code>Docker daemon</code>（<code>docker</code>守护进程)时，会自动创建<strong>网桥</strong>（<code>bridge network</code>），称为:<code>bridge</code>，即对应host上的<code>docker0</code>。<code>Docker network</code>会自动在主机中安装规则，以阻止不同网桥上的容器进行相互通信。</p><p>查看主机上的网络设备<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ ip addr </span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: enp0s3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 08:00:27:eb:89:b8 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.0.2.15/24 brd 10.0.2.255 scope global noprefixroute dynamic enp0s3</span><br><span class="line">       valid_lft 84147sec preferred_lft 84147sec</span><br><span class="line">    inet6 fe80::eef9:c7e0:7365:65b6/64 scope link noprefixroute </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: enp0s8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 08:00:27:22:76:1d brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.56.102/24 brd 192.168.56.255 scope global noprefixroute dynamic enp0s8</span><br><span class="line">       valid_lft 996sec preferred_lft 996sec</span><br><span class="line">    inet6 fe80::a88:e4da:b641:f973/64 scope link noprefixroute </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">4: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default </span><br><span class="line">    link/ether 02:42:60:e0:e9:55 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:60ff:fee0:e955/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure></p><p>查看docker网络驱动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">b549b06a92e7        bridge              bridge              local</span><br><span class="line">c5149e25deea        host                host                local</span><br><span class="line">bfa90bfc3dfe        none                null                local</span><br></pre></td></tr></table></figure></p><p><strong>网桥</strong><code>bridge network</code>适用于在同一个Docker守护进程的主机上运行的容器。对于在不同Docker守护进程主机上运行的容器之间的通信，可以在操作系统级别管理路由，可以使用原生的<a href="https://docs.docker.com/network/overlay/" target="_blank" rel="noopener">覆盖网络<code>overlay</code></a>和<a href="https://docs.docker.com/network/macvlan/" target="_blank" rel="noopener"><code>macvlan</code></a>。也可使用第三方网络插件：常用的包括 flannel、weave 和 calico</p><p>如果用户启动一个新的容器（<code>container</code>），则默认会连接到该网桥，除非在启动容器时指定了自定义网桥（<code>self-defined bridge networks</code>）。<br><strong>自定义网桥</strong>在容器安全性、容器间通信等方面优于默认网桥（<code>bridge</code>）</p><h4 id="用户定义的网桥与默认网桥之间的区别"><a href="#用户定义的网桥与默认网桥之间的区别" class="headerlink" title="用户定义的网桥与默认网桥之间的区别"></a>用户定义的网桥与默认网桥之间的区别</h4><ul><li><p>用户定义的网桥可在容器化应用程序（<code>container application</code>）之间提供更好的隔离性和连通性<br>连接到同一个用户定义的网桥的容器会自动将所有端口相互暴露，而不会向外界暴露任何端口。这使得容器中的应用程序可以轻松地相互通信，而阻止外界对容器的访问。</p><p>比如：有一个web前端和db后端两个容器，集群外部需要访问web前端（比如80端口）。使用用户定义的网桥，可以实现允许外部访问web前端，阻止访问db后端（比如：3306）。而web前端可以通过自定义网桥对db容器进行访问。<br>如果在默认网桥上运行相同的应用程序（web前端和db后端），则需要同时暴露Web端口（80）和数据库端口（3306），并为每个端口使用-p或–publish标志。 这意味着Docker主机需要通过其他方式阻止对db数据库端口的访问。</p></li><li><p>用户定义的桥接器在容器之间提供自动DNS解析<br>默认网桥上的容器只能通过IP地址相互访问（无法直接访问IP:PORT），除非您使用<code>--link</code>选项（该属性官方建议后续不再使用）。 而在用户定义的桥接网络上，容器可以通过名称或别名相互解析。<br>还拿上个例子说明：如果在默认网桥上运行web容器和db容器，则需要在容器之间手动的创建链接（<code>--link</code>）。如果容器数量达到几十或者几百，那么工作量将会非常大。</p></li><li><p>容器可以在运行中与用户定义的网络连接和分离</p></li><li><p>每个用户定义的网络都会创建一个可配置的网桥<br>如果容器使用默认桥接网络，则可以对其进行配置，但所有容器都使用相同的设置，例如MTU（最大传输数据包大小）和iptables规则。 此外，配置默认桥接网络，需要重新启动Docker。 使用<code>docker network create</code>创建和配置用户定义的网桥。 如果不同的应用程序组具有不同的网络要求，则可以在创建时单独配置每个用户定义的网桥。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create my-net</span><br></pre></td></tr></table></figure></li><li><p>默认桥接网络上的链接容器共享环境变量<br>最初，在两个容器之间共享环境变量的唯一方法是使用–link标志链接它们。 用户定义的网络无法实现这种类型的变量共享。 但是，有更好的方法来共享环境变量。 一些想法：</p><ul><li><p>多个容器可以挂载包含共享信息的文件或目录，使用<code>Docker volume</code>挂载卷进行文件或者变量共享。</p></li><li><p>可以使用<code>docker-compose</code>一起启动多个容器，并且compose文件可以定义共享变量。</p></li><li><p>您可以使用集群服务（<code>swamp service</code>）而不是独立容器，并利用<a href="https://docs.docker.com/engine/swarm/secrets/" target="_blank" rel="noopener"><code>secrets</code></a>和<a href="https://docs.docker.com/engine/swarm/configs/" target="_blank" rel="noopener"><code>configs</code></a>共享变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">   --name nginx \</span><br><span class="line">   --secret site.key \</span><br><span class="line">   --secret site.crt \</span><br><span class="line">   --config source=site.conf,target=/etc/nginx/conf.d/site.conf,mode=0440 \</span><br><span class="line">   --publish published=3000,target=443 \</span><br><span class="line">   nginx:latest \</span><br><span class="line">   sh -c &quot;exec nginx -g &apos;daemon off;&apos;&quot;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="创建用户自定义网桥（self-define-）"><a href="#创建用户自定义网桥（self-define-）" class="headerlink" title="创建用户自定义网桥（self-define ）"></a>创建用户自定义网桥（self-define ）</h4><ul><li><p>使用命令<code>docker network create</code> 命令创建用户自定义网络</p><p> 具体使用方法可以使用<code>docker network create --help</code>获取帮助  </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create \</span><br><span class="line"> --driver=bridge \</span><br><span class="line"> --subnet=172.28.0.0/16 \</span><br><span class="line"> --ip-range=172.28.5.0/24 \</span><br><span class="line"> --gateway=172.28.5.254 \</span><br><span class="line">    br0</span><br></pre></td></tr></table></figure></li><li><p>使用命令<code>docker network rm</code>命令删除已存在的网络</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network rm my-net</span><br></pre></td></tr></table></figure></li></ul><p>当用户<strong>删除</strong>或<strong>创建</strong>网络，或者用户将容器连接（断开连接）到自定义网络时，操作系统会管理底层网络基础架构（创建（删除）网桥或者修改<code>iptables</code>规则）。这些操作对用户来说是透明的。</p><h4 id="连接容器到自定义网络"><a href="#连接容器到自定义网络" class="headerlink" title="连接容器到自定义网络"></a>连接容器到自定义网络</h4><p>用户在创建容器时，可以指定连接到自定义网络（使用<code>--network</code>方式）；也可以将正在运行的（runing)的容器连接到自定义网络。</p><ul><li><p>创建容器，并连接到自定义网络</p><p>例如：创建<code>Nginx</code>容器，连接到<code>my-net</code>网络中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker create --name my-nginx \</span><br><span class="line">   --network my-net \</span><br><span class="line">   --publish 8080:80 \</span><br><span class="line">   nginx:latest</span><br></pre></td></tr></table></figure><p>创建一个容器<code>my-nginx</code>，连接到已存在的<code>my-net</code> 网络中，并且将容器内部开放的80端口映射到宿主机的8080端口上。在容器外部，可以通过8080端口访问该容器。</p></li><li><p><code>running</code>容器连接到自定义网络中</p><p>启动<code>my-nignx</code>容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name my-nginx \</span><br><span class="line">   --publish 8080:80 \</span><br><span class="line">   nginx:latest</span><br></pre></td></tr></table></figure><p>连接到<code>my-net</code>自定义网络</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network connect my-net my-nginx</span><br></pre></td></tr></table></figure><p>如果启动docker容器时，不指定自定义网桥，则容器会连接默认网桥。连接到默认网桥的容器客户相互通信，但是只能通过IP地址进行通信。</p></li></ul><h4 id="修改Docker默认网桥"><a href="#修改Docker默认网桥" class="headerlink" title="修改Docker默认网桥"></a>修改Docker默认网桥</h4><p>修改默认网桥，有两种方式：修改dockerd启动配置文件 和 修改Docker守护进程daemon.json文件</p><ul><li><p>修改dockerd启动配置文件</p><p>dockerd启动文件默认位置：<code>/usr/lib/systemd/system/docker.service</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">ExecStart=/usr/bin/dockerd -H unix:///var/run/docker.sock \</span><br><span class="line">  -H tcp://0.0.0.0:2376 \</span><br><span class="line">  --bip=10.2.54.1/24 \ </span><br><span class="line">  --mtu=1450 \ </span><br><span class="line">  --dns=[&quot;10.20.1.2&quot;,&quot;10.20.1.3&quot;]</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>daemon.json文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;bip&quot;: &quot;192.168.1.5/24&quot;,</span><br><span class="line">   &quot;fixed-cidr&quot;: &quot;192.168.1.5/25&quot;,</span><br><span class="line">   &quot;fixed-cidr-v6&quot;: &quot;2001:db8::/64&quot;,</span><br><span class="line">   &quot;mtu&quot;: 1500,</span><br><span class="line">   &quot;default-gateway&quot;: &quot;10.20.1.1&quot;,</span><br><span class="line">   &quot;default-gateway-v6&quot;: &quot;2001:db8:abcd::89&quot;,</span><br><span class="line">   &quot;dns&quot;: [&quot;10.20.1.2&quot;,&quot;10.20.1.3&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>使参数生效，则需要重启Docker守护进程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Docker网络驱动(network driver)之————网桥(bridge)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在《计算机网络》这本教材中，我们学习过，&lt;strong&gt;网桥&lt;/strong&gt;是一种工作在数据链路层，对帧进行转发的技术，它根据MAC帧的目标地址对收
      
    
    </summary>
    
      <category term="运维" scheme="http://172.104.32.215/categories/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="docker" scheme="http://172.104.32.215/categories/%E8%BF%90%E7%BB%B4/docker/"/>
    
    
      <category term="docker" scheme="http://172.104.32.215/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker网络驱动之--overlay网络</title>
    <link href="http://172.104.32.215/2019/03/22/docker-network-overlay/"/>
    <id>http://172.104.32.215/2019/03/22/docker-network-overlay/</id>
    <published>2019-03-21T20:23:46.000Z</published>
    <updated>2019-03-21T12:25:46.633Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>docker overlay</code>网络用于创建多个docker主机之间的分布式网络。该网络位于（覆盖）特定于主机的网络之上，可以将<code>swarm</code>集群服务和<code>containers</code>容器与<code>overlay</code>网络进行连接，使各个服务或者服务与容器之间进行通信。</p></blockquote><h4 id="创建或加入swarm服务"><a href="#创建或加入swarm服务" class="headerlink" title="创建或加入swarm服务"></a>创建或加入<code>swarm</code>服务</h4><p>在创建和使用<code>overlay</code>之前，必须初始化一个<a href="https://docs.docker.com/engine/swarm/" target="_blank" rel="noopener"><code>swarm</code></a>或者加入某个<code>swarm</code>:</p><ul><li><p>创建一个<code>swarm</code>集群服务</p><p>用法：<code>docker swarm init [OPTIONS]</code>，针对常用的<code>[OPTIONS]</code>介绍见下方表格：</p><p>参数说明</p><p>|参数|类型|默认值|说明|<br>|—–|—–|—–|—–|<br>|<code>--advertise-addr</code>| string ||多块网卡时对应多个IP地址时，需要指定|<br>|<code>--data-path-addr</code>|string||用于数据流量传输的IP地址或者网卡名称（例：<code>eth0</code>）|<br>|<code>--listen-addr</code>|node-addr|0.0.0.0:2377|监听地址|</p></li></ul><p>  <strong>示例：创建<code>swarm</code>服务</strong></p><p>  我们用两个节点进行演示，一个node既是管理节点，工作节点；一个node仅是工作节点：</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node1 : 192.168.0.190  (manager &amp; worker)</span><br><span class="line">node2 : 192.168.0.191 (worker)</span><br></pre></td></tr></table></figure><p>   <img src="/images/swarmcluster.png" alt="swarm架构"></p><ul><li><p>创建<code>swarm</code>集群服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm init --advertise-addr 192.168.0.190</span><br><span class="line">Swarm initialized: current node      (se5tsje7l9oibpsx54bbe7nuf) is now amanager.</span><br><span class="line">To add a worker to this swarm, run the following      command:</span><br><span class="line">  docker swarm join      --tokenSWMTKN-1-45ffvnn83wrl0aprynpcs0cogtg951kns  t fq  n7ok98hizonw9s-e5p7e5yjfit5tx6l1kp3e6d9      192.168.0.190:2377</span><br><span class="line">To add a manager to this swarm, run &apos;docker swarm      join-tokenmanager&apos; and follow the instructions.</span><br></pre></td></tr></table></figure></li></ul><pre><code>注意到执行初始化`swarm`语句时，会打印出其他node节点加 入该`swarm`的方式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join --token xxxx &lt;manager-ip&gt;:&lt;port&gt;</span><br></pre></td></tr></table></figure>可以将其保存到文档，以便于后续`swarm`Node的[join]   (https://docs.docker.   com/engine/reference/commandline/swarm_join/)。查看docker网络<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER                 SCOPE</span><br><span class="line">ba18dbad1160        bridge              bridge                 local</span><br><span class="line">58886c346808        docker_gwbridge     bridge                 local</span><br><span class="line">7966432ad37e        host                host                   local</span><br><span class="line">yryhkokko1tk        ingress             overlay                swarm</span><br><span class="line">d1ab833f3555        none                null                   local</span><br></pre></td></tr></table></figure>可以看到在docker网络中，新增了`ingress`和 `docker_gwbridge`网络。- `ingress`  一个名为ingress的覆盖网络，用于处理与`swarm`服务相关   的控制和数据流量。创建`swarm`服务时，如果不将其连接   到用户定义的覆盖网络，则默认情况下会连接到该   `ingress`网络  使用 `docker network inspect ingress`查看现有的   `ingress`网络。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect ingress</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;ingress&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;yryhkokko1tkpkhx0pf0e1zm3&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2019-01-08T17:05:50.511486192+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;swarm&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;overlay&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: null,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;10.255.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;10.255.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: true,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;ingress-sbox&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;ingress-endpoint&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;75df50d1f8228ff64d65a6801bc2a93e31de3f72adaec01e147abd266d3d64eb&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:0a:ff:00:03&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;10.255.0.3/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;</span><br><span class="line">            &quot;com.docker.network.driver.overlay.vxlanid_list&quot;: &quot;4096&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Peers&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;5e8427535708&quot;,</span><br><span class="line">                &quot;IP&quot;: &quot;192.168.0.190&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;42c5607b0c46&quot;,</span><br><span class="line">                &quot;IP&quot;: &quot;192.168.0.191&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>- `docker_gwbridge`  一个名为`docker_gwbridge`的桥接网络，它用于各个  `swarm`中，各个node节点进行通信的桥接网络。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect docker_gwbridge</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;docker_gwbridge&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;2c7254c25f765b28833668e060246a813d69b8936a5db1a8cd2bc7237dfc7df4&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2019-01-08T17:05:51.263715613+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: null,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.18.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.18.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;ingress-sbox&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;gateway_ingress-sbox&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;4f6821a4096104af4f04aea5caab7a5a3419a2b6469b31ea7a52f4c92b9023af&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.18.0.2/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;</span><br><span class="line">            &quot;com.docker.network.bridge.enable_icc&quot;: &quot;false&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.name&quot;: &quot;docker_gwbridge&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>增加工作（<code>worker</code>）节点</p><p>  将node2(192.168.0.191)加入到该<code>swarm</code>：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm join --token \</span><br><span class="line">  SWMTKN-1-45ffvnn83wrl0aprynpcs0cogtg951knstfqn7ok98hizonw9s-e5p7e50yjfit5tx6l1kp3e6d9  \</span><br><span class="line">  192.168.0.190:2377</span><br><span class="line"></span><br><span class="line">  This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure><p>  查看node</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker node ls</span><br><span class="line">  ID                            HOSTNAME             STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION</span><br><span class="line">  se5tsje7l9oibpsx54bbe7nuf *   host1                 Ready               Active              Leader              18.03.1-ce</span><br><span class="line">  timpbicei0sxbsuv9rq1625eh     host2                 Ready               Active                                  18.03.1-ce</span><br></pre></td></tr></table></figure></li></ul><pre><code>查看**工作节点**的docker网络<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker network ls </span><br><span class="line">  NETWORK ID          NAME                DRIVER                    SCOPE</span><br><span class="line">  e39a5d50e807        bridge              bridge                    local</span><br><span class="line">  2c7254c25f76        docker_gwbridge     bridge                    local</span><br><span class="line">  a284efd6e1f2        host                host                      local</span><br><span class="line">  yryhkokko1tk        ingress             overlay                   swarm</span><br><span class="line">  13bd88a34632        none                null                  local</span><br></pre></td></tr></table></figure></code></pre><h4 id="overlay网络"><a href="#overlay网络" class="headerlink" title="overlay网络"></a><code>overlay</code>网络</h4><ul><li><p>创建<code>overlay</code>网络</p><p>在创建<code>overlay</code>网络前，需要初始化或者加入<code>swarm</code>服务。即使可能后续不会使用<code>swarm</code>服务，也需要执行此操作。之后，您可以创建其他用户定义的覆盖网络。</p><p>要创建用于swarm服务的覆盖网络，请使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create -d overlay my-overlay</span><br></pre></td></tr></table></figure><p>要创建可由群集服务或独立容器用于与在其他Docker守护进程主机上运行的其他独立容器通信的<code>overlay</code>网络，必须添加<code>--attachable</code>标志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create -d overlay --attachable my-attachable-overlay</span><br></pre></td></tr></table></figure><p>在创建可以指定IP地址范围，子网，网关和其他选项。有关详细信息，请参阅docker network create –help</p></li><li><p><code>overlay</code>网络流量加密（不支持windows操作系统）</p><p>在<code>swarm</code>服务中的管理流量默认是通过<code>GCM-AES</code>加密算法进行加密。如果尝试对容器间的流量进行加密，在创建覆盖网络时添加<code>--opt encrypted</code>属性，Docker会在各个工作节点之间建立<code>IPSEC</code>隧道。但是通常加密解密操作需要消耗一定的性能，若将网络加密应用于生产环境，一定对该性能损耗进行评估。</p></li></ul><ul><li><p>自定义默认<code>ingress</code></p><p>Docker 17.05之后的版本，才支持用户修改默认<code>ingress</code>网络。如果自动选择的子网与网络上已存在的子网冲突，或者您需要自定义其他<code>low-level</code>底层网络设置（如MTU），则此功能非常有用。</p><ul><li><p>创建<code>ingress</code>网络</p><p>使用–ingress标志创建新的覆盖网络，以及要设置的自定义  选项。此示例将MTU设置为1200，将子网设置为10.11.0.0/16，并将网关设置为10.11.0.2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create \</span><br><span class="line">  --driver overlay \</span><br><span class="line">  --ingress \</span><br><span class="line">  --subnet=10.11.0.0/16 \</span><br><span class="line">  --gateway=10.11.0.2 \</span><br><span class="line">  --opt com.docker.network.driver.mtu=1200 \</span><br><span class="line">  my-ingress</span><br></pre></td></tr></table></figure><p>注意：您可以对<code>ingress</code>网络重新命名，但您只能拥有一个<code>ingress</code>网络。</p></li><li><p>删除<code>ingress</code>网络</p><p>如果现有服务有发布端口，则需要先删除这些服务，然后才能删除<code>ingress</code>网络。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker network rm ingress</span><br><span class="line"> </span><br><span class="line">  WARNING! Before removing the routing-mesh   network, make sure all the nodes</span><br><span class="line">  in your swarm run the same docker engine   version. Otherwise, removal may not</span><br><span class="line">  be effective and functionality of newly created   ingress networks will be</span><br><span class="line">  impaired.</span><br><span class="line">  Are you sure you want to continue? [y/N]</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>自定义<code>docker_gwbridge</code></p><p><code>docker_gwbridge</code>是一个虚拟网桥，将覆盖网络（包括<code>ingress</code>网络）连接到单个Docker守护程序的物理网络，它存在于Docker主机的内核中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ip addr | grep docker_gwbridge</span><br><span class="line">  docker_gwbridge: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;   mtu 1500 qdisc noqueue state UP </span><br><span class="line">    inet 172.18.0.1/16 brd 172.18.255.255 scope   global docker_gwbridge</span><br></pre></td></tr></table></figure></li></ul><ol><li><p>Stop Docker service</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl stop docker</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>删除<code>docker_gwbridge</code>网桥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ip link set  docker_gwbridge down</span><br><span class="line">$ ip link del dev docker_gwbridge</span><br></pre></td></tr></table></figure></li><li><p>启动Docker，但是不要初始化<code>swarm</code>或者加入任何<code>swarm</code>  服务网络</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start docker</span><br></pre></td></tr></table></figure></li><li><p>使用<code>docker network create</code>命令，使用自定义设置手动  创建或重新创建<code>docker_gwbridge</code>桥。此示例使用子网  10.11.0.0/16。有关可自定义选项的完整列表，请参阅[Bridge  驱动程序选项]  (<a href="https://docs.docker.com/engine/reference/commandline/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/</a>  network_create/#bridge-driver-options)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create  \</span><br><span class="line">  --subnet 10.11.0.0/16 \</span><br><span class="line">  --opt    com.docker.network.bridge.name=docker_gwbridge \</span><br><span class="line">  --opt com.docker.network.bridge.enable_icc=false  \</span><br><span class="line">  --opt    com.docker.network.bridge.enable_ip_masquerade=true \</span><br><span class="line">  docker_gwbridge</span><br></pre></td></tr></table></figure></li><li><p>初始化或加入<code>swarm</code>服务集群。由<code>docker_gwbridge</code>网桥已经存在，初始化时Docker不再创建它。</p></li></ol><h4 id="创建用于swarm服务的overlay网络"><a href="#创建用于swarm服务的overlay网络" class="headerlink" title="创建用于swarm服务的overlay网络"></a>创建用于<code>swarm</code>服务的<code>overlay</code>网络</h4><ul><li><p>在<code>overlay</code>网络上，暴露服务端口号</p><p>连接到同一覆盖网络的群集服务有效地将所有端口彼此暴露。对于可在服务外部访问的端口，必须使用<code>docker service create</code>或<code>docker service update</code>上的<code>-p</code>或<code>--publish</code>参数发布端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker service create</span><br></pre></td></tr></table></figure><p>默认情况下，发布端口的<code>swarm</code>服务使用路由网格(<code>routing mesh</code>)来实现。如果连接到当您连接到任何swarm节点上的已发布端口（无论它是否正在运行给定服务）时，您将被透明地重定向到正在运行该服务的worker。</p></li><li><p><code>swram</code>服务区（<code>swarm service</code>）绕过网格路由（<code>routing mesh</code>）</p><p>默认情况下，发布端口的<code>swarm</code>服务使用路由网格来实现负载均衡。 当您连接到任意一个<code>swarm</code>节点（工作节点和管理节点）上的已发布端口（无论该节点上是否运行了要访问的服务）时，您将被透明地路由到正在运行该服务的<code>worker</code>节点上。实际上，Docker充当您的群服务的负载均衡器（<code>load balancer</code>）。 默认情况下，使用<code>routing mesh</code>的服务以虚拟IP（VIP）模式运行。 即使在每个节点上运行的服务（通过<code>--mode global</code>）也使用路由网格。使用<code>routing mesh</code>时，无法保证哪个Docker节点响应客户端请求。要绕过路由网格，可以使用DNS循环（DNSRR）模式启动服务，方法是将<code>--endpoint-mode</code>标志设置为<code>dnsrr</code>。若使用<code>dnsrr</code>，需要在服务前运行自己的负载均衡器（常用的：有<code>nginx</code>、<code>HAproxy</code>）。通过DNS查询返回运行在<code>swarm</code>集群服务的所有节点的IP地址列表。</p><blockquote><p><code>routing mesh</code> 将外部请求路由到不同主机的容器，从而实现了外部网络对 <code>service</code> 的访问。</p></blockquote></li><li><p>分离控制流量和数据流量</p><p>默认情况下，与<code>swarm</code>管理相关的控制流量以及应用程序的数据流量都在同一网络上运行，尽管群集控制流量已加密。您可以将Docker配置为使用单独的网络接口来处理两种不同类型的流量。初始化或加入<code>swarm</code>时，每个节点（管理节点和工作节点）需要分别指定<code>--advertise-addr</code>和<code>--data-path-addr</code>。</p></li></ul><h4 id="创建用于独立容器使用的overlay网络"><a href="#创建用于独立容器使用的overlay网络" class="headerlink" title="创建用于独立容器使用的overlay网络"></a>创建用于独立容器使用的<code>overlay</code>网络</h4><ul><li><p>将独立容器连接到覆盖网络</p><p>在创建<code>ingress</code>网络时，若未指定<code>--attachable</code>（比如初始化<code>swarm</code>服务，或加入<code>swarm</code>时默认创建的<code>ingress</code>）意味着只有<code>swarm</code>服务可以使用它，独立运行的容器无法使用<code>ingress</code>。您可以将独立容器连接到使用–attachable标志创建的用户定义的覆盖网络。这使得在不同Docker守护程序上运行的独立容器能够进行通信，而无需在各个Docker守护程序主机上设置路由。</p></li></ul><ul><li><p>容器发现</p><p>在大多数情况下，您应该连接到服务名称，该名称是负载平衡的，并由支持该服务的所有容器（“tasks”）处理。要获取支持该服务的所有任务的列表，使用<code>DNS lookup</code> 查找<code>tasks.&lt;service-name&gt;</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;docker overlay&lt;/code&gt;网络用于创建多个docker主机之间的分布式网络。该网络位于（覆盖）特定于主机的网络之上，可以将&lt;code&gt;swarm&lt;/code&gt;集群服务和&lt;code&gt;containers&lt;/code&gt;容器与
      
    
    </summary>
    
      <category term="运维" scheme="http://172.104.32.215/categories/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="docker" scheme="http://172.104.32.215/categories/%E8%BF%90%E7%BB%B4/docker/"/>
    
    
      <category term="docker" scheme="http://172.104.32.215/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>python 多线程锁机制介绍</title>
    <link href="http://172.104.32.215/2019/03/21/python-mulit-thread/"/>
    <id>http://172.104.32.215/2019/03/21/python-mulit-thread/</id>
    <published>2019-03-21T15:56:07.000Z</published>
    <updated>2019-03-21T11:41:49.289Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><ul><li>说明：</li></ul><p>对共享内存（资源），进行加锁，释放锁。保证同一时间，只有一个线程对共享资源进行操作。即保证了对共享资源的原子操作。</p><ul><li>使用：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">_lock = threading.lock() # 定义锁 _local</span><br><span class="line"></span><br><span class="line">_lock.accquire()  # 获取锁</span><br><span class="line"># TODO do something</span><br><span class="line">do_somthing(share_var)   # 操作共享资源</span><br><span class="line">_lock.release()  #释放锁</span><br></pre></td></tr></table></figure><ul><li><p>缺点：</p><p>死锁</p><p>当有多个共享资源（比如：<code>R_A</code>, <code>R_B</code>），多个线程（比如：<code>T_A</code>, <code>T_B</code>），每个线程都需要操作共享资源。假如线程 <code>T_A</code> 已经获取了共享资源 <code>R_A</code>，<code>T_B</code> 获取了共享资源 <code>R_B</code> ， 而线程 <code>T_A</code> 等待 <code>T_B</code> 释放共享资源 <code>R_B</code> 。 同时，线程 <code>T_B</code> 等待 <code>T_A</code> 释放共享资源 <code>R_A</code> ，此时就陷入死锁状态。</p></li></ul><h3 id="RLock"><a href="#RLock" class="headerlink" title="RLock"></a>RLock</h3><ul><li><p>说明：</p><p>RLock 其实叫做“Reentrant Lock”，就是可以重复进入的锁，也叫做“递归锁”。这种锁对比 <code>Lock</code> 有是四个特点：</p><ol><li>谁获取谁释放。如果线程A获取锁，线程B无法释放这个锁，只有A可以释放；而 <code>Lock</code> 锁，可以被另外一个线程所释放。</li><li>同一线程可以多次获取到该锁，即可以acquire多次；</li><li>如果使用RLock，那么acquire和release必须成对出现。acquire多少次就必须release多少次，只有最后一次release才能改变RLock的状态为unlocked）</li><li>相对 <code>Rlock</code> ， <code>Lock</code> 速度更快。</li></ol></li><li><p>使用：</p><p>使用 <code>Rlock</code> 锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import threading  </span><br><span class="line">rLock = threading.RLock()  #RLock对象  </span><br><span class="line">rLock.acquire()  </span><br><span class="line">rLock.acquire() #在同一线程内，程序不会堵塞。  </span><br><span class="line">rLock.release()  </span><br><span class="line">rLock.release()</span><br></pre></td></tr></table></figure></li></ul><p>  使用 <code>Lock</code> 锁：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import threading  </span><br><span class="line">lock = threading.Lock() #Lock对象  </span><br><span class="line">lock.acquire()  </span><br><span class="line">lock.acquire()  #产生了死琐。  </span><br><span class="line">lock.release()  </span><br><span class="line">lock.release()</span><br></pre></td></tr></table></figure><ul><li>缺点：</li></ul><h3 id="semaphore（信号量）"><a href="#semaphore（信号量）" class="headerlink" title="semaphore（信号量）"></a>semaphore（信号量）</h3><ul><li><p>说明：</p><p>信号量是由操作系统管理的一个内部的数据结构，用于表示共享资源当前支持有多少并发线程进行操作。当信号量为<strong>负值</strong>时，那么所有想获取共享资源的线程被挂起，直到有线程释放信号量，信号量的值变成<strong>非负值</strong>时。</p><p>本质上，信号量就是一个计数器，当计数器的值为 <strong>非负值</strong> 时， 通知其他线程，可以对共享资源进行竞争。当计数器的值为 <strong>负值</strong> 时，所有待获取共享资源的线程挂起状态。</p></li></ul><ul><li><p>使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">semaphore = threading.Semaphore(0)</span><br><span class="line"></span><br><span class="line"># Thread1:</span><br><span class="line">def thread1_method():</span><br><span class="line">    semaphore.acquire()  # 线程1 对信号量进行获取操作</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Thread2:</span><br><span class="line">def thread2_method():</span><br><span class="line">  semaphore.release()  # 线程2 对信号量进行释放操作，可以提高计数器</span><br></pre></td></tr></table></figure></li></ul><p>  信号量的 release() 可以对计数器加 1 操作。然后通知其他的线程，如果信号量的计数器到了0，就会阻塞 acquire() 方法，直到得到另一个线程的release()操作，通知。如果信号量的计数器大于0，就会对这个值 -1 然后分配资源。</p><ul><li><p>缺点：</p><p>导致死锁</p><p>有多个线程（比如：<code>t1</code> ， <code>t2</code>），竞争多个信号量（比如：<code>s1</code> , <code>s2</code>）。 假如，现在有一个线程 <code>t1</code> 先等待信号量 <code>s1</code> ，然后等待信号量 <code>s2</code> ，而线程 <code>t2</code> 会先等待信号量 <code>s2</code> ，然后再等待信号量 <code>s1</code> ，这样就可能会发生死锁，导致 <code>t1</code> 等待 <code>s2</code> ，但是 <code>t2</code> 在等待 <code>s1</code> 。</p></li></ul><h3 id="Condition-条件同步"><a href="#Condition-条件同步" class="headerlink" title="Condition - 条件同步"></a>Condition - 条件同步</h3><ul><li><p>说明：</p><p>当多个线程<strong>等待</strong>同一个条件时，当条件发生的时候，会通知所有等待该条件的线程。比如生产者消费者里的例子：在消费者线程里，只要篮子（共享资源）不满（条件），消费者线程通知生产者线程可以操作该篮子（共享资源）；在生产者线程里，只要篮子不空（条件），生产者线程通知消费者线程可操作该篮子。</p></li><li><p>使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line">condition = threading.Condition()</span><br><span class="line"></span><br><span class="line">#  生产者</span><br><span class="line">def thread1_method():</span><br><span class="line">  condition.acquire()</span><br><span class="line">  # 条件判断</span><br><span class="line">  if (condition_var == False)：  # 条件不满足       </span><br><span class="line">      condition.wait()  # 释放锁，线程挂起，等待被其他线程唤醒</span><br><span class="line">  </span><br><span class="line">  # TODO do something</span><br><span class="line"></span><br><span class="line">  condition.notify()  # 条件满足，通知其他线程</span><br><span class="line">  condition.release()  # 释放资源</span><br><span class="line"></span><br><span class="line"># 消费者</span><br><span class="line">def thread2_method():</span><br><span class="line">   </span><br><span class="line">  condition.accquire()</span><br><span class="line">  # 条件判断</span><br><span class="line">  if (condition_var == False)：  # 条件不满足       </span><br><span class="line">       condition.wait()  # 释放锁，线程挂起，等待被其他线程唤醒</span><br><span class="line"></span><br><span class="line">  # 条件满足</span><br><span class="line">  # TODO  do something</span><br><span class="line"></span><br><span class="line">  condition.notify()  # 条件满足，通知其他线程</span><br><span class="line">  condition.release()   # 释放资源</span><br></pre></td></tr></table></figure><p><code>wait</code> 方法释放内部所占用的琐，同时线程被挂起，直至接收到通知被唤醒或超时（如果提供了timeout参数的话）。当线程被唤醒并重新占有琐的时候，程序才会继续执行下去。</p><p><code>notify</code> 唤醒一个挂起的线程（如果存在挂起的线程）。注意：<code>notify()</code>方法不会释放所占用的琐。需要通过 <code>release()</code> 方法释放锁。</p></li></ul><ul><li>缺点：</li></ul><h3 id="Event-事件"><a href="#Event-事件" class="headerlink" title="Event - 事件"></a>Event - 事件</h3><ul><li>说明：</li><li><p>使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">event = threading.Event()</span><br></pre></td></tr></table></figure></li><li><p>缺点：</p></li></ul><p><strong>参考：</strong></p><ul><li><p><a href="https://python-parallel-programmning-cookbook.readthedocs.io/zh_CN/latest/chapter2/index.html" target="_blank" rel="noopener">基于线程的并行</a></p></li><li><p><a href="https://stackoverflow.com/questions/22885775/what-is-the-difference-between-lock-and-rlock" target="_blank" rel="noopener">What is the difference between Lock and RLock</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Lock&quot;&gt;&lt;a href=&quot;#Lock&quot; class=&quot;headerlink&quot; title=&quot;Lock&quot;&gt;&lt;/a&gt;Lock&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;说明：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对共享内存（资源），进行加锁，释放锁。保证同一时间，只有一个线程对共享资源进
      
    
    </summary>
    
    
      <category term="Python" scheme="http://172.104.32.215/tags/Python/"/>
    
      <category term="thread" scheme="http://172.104.32.215/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>gcr.io和quay.io拉取镜像失败</title>
    <link href="http://172.104.32.215/2019/03/21/pull-docker-images-failed/"/>
    <id>http://172.104.32.215/2019/03/21/pull-docker-images-failed/</id>
    <published>2019-03-21T11:17:18.000Z</published>
    <updated>2019-03-21T11:41:49.289Z</updated>
    
    <content type="html"><![CDATA[<p>k8s在使用编排（manifest）工具进行yaml文件启动pod时，会遇到官方所给例子中<code>spec.containers.image</code>包含：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">quay.io/coreos/example_</span><br><span class="line">gcr.io/google_containers/example_</span><br></pre></td></tr></table></figure></p><p>也就是说，从quay.io和gcr.io进行镜像拉取，我们知道，国内访问外网是被屏蔽了的。可以将其替换为 quay-mirror.qiniu.com 和 registry.aliyuncs.com</p><ul><li><p>例如<br>  <strong>下拉镜像</strong>：<code>quay.io/coreos/flannel:v0.10.0-s390x</code><br>  如果拉取较慢，可以改为：<code>quay-mirror.qiniu.com/coreos/flannel:v0.10.0-s390x</code></p><p>  <strong>下拉镜像</strong>：<code>gcr.io/google_containers/kube-proxy</code><br>  可以改为： <code>registry.aliyuncs.com/google_containers/kube-proxy</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;k8s在使用编排（manifest）工具进行yaml文件启动pod时，会遇到官方所给例子中&lt;code&gt;spec.containers.image&lt;/code&gt;包含：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
      <category term="运维" scheme="http://172.104.32.215/categories/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="docker" scheme="http://172.104.32.215/categories/%E8%BF%90%E7%BB%B4/docker/"/>
    
    
      <category term="docker" scheme="http://172.104.32.215/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker存储原理——介绍</title>
    <link href="http://172.104.32.215/2019/03/21/docker-storage/"/>
    <id>http://172.104.32.215/2019/03/21/docker-storage/</id>
    <published>2019-03-21T08:46:02.000Z</published>
    <updated>2019-03-21T12:19:28.918Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker数据存储"><a href="#Docker数据存储" class="headerlink" title="Docker数据存储"></a>Docker数据存储</h2><blockquote><p>在Docker中，有两种方式对数据进行存储：<code>docker volume</code>(存储卷) 和 <code>docker storage driver</code>（存储驱动），本文主要介绍<code>docker storage driver</code>存储驱动。</p></blockquote><p>准备工作：</p><p>OS: centos 7.4 (kernel version &gt; 3.10.514 )</p><p>Docker: docker-ce 18.03.1 ( <a href="http://www.weshzhu.com/2019/01/03/binary-install-docker-ce-on-centos7/" target="_blank" rel="noopener">docker-ce安装教程</a>)</p><h4 id="Docker-数据存储"><a href="#Docker-数据存储" class="headerlink" title="Docker 数据存储"></a>Docker 数据存储</h4><p>在了解<code>Docker storage driver</code>之前，我们先了解一下Docker如何存储容器数据和镜像数据。在Docker中数据分为镜像数据和容器数据，容器数据又包含容器可写层和<code>docker volume</code>存储。镜像数据是一种静态数据，存储了提供容器运行的程序、配置文件等。容器数据可以理解为动态 + 静态的数据（阅读本文后，可能有比较直观的理解），供容器运行使用。</p><p>   <img src="/images/container-layers.jpg" alt></p><p>如上图所示，容器层（high-level）是非常小的层，允许程序对该层读写操作；镜像层(low-level)包含了大部分的数据，并且是只读的。在镜像未启动时均是以镜像层存储在host主机上（存储路径：<code>/var/lib/docker/&lt;storage-driver&gt;/</code>）。以该镜像为基础，通过<code>docker run</code>启动一个或多个容器后，针对每个启动的容器会增加一层——可读写层（容器层）。</p><ul><li><p>镜像层<br>Docker镜像是由一系列的层（<code>layer</code>）构成，镜像的每个<code>layer</code>对应这个Dockerfile中的每条指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:15.04</span><br><span class="line">COPY . /app</span><br><span class="line">RUN mkdir -p /app/conf/</span><br><span class="line">CMD python /app/app.py</span><br></pre></td></tr></table></figure><p>通过<code>docker build -t</code>命令构建镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t my-ubuntu:test -f Dockerfile .</span><br><span class="line">  </span><br><span class="line">  Sending build context to Docker daemon  3.584kB</span><br><span class="line">  Step 1/4 : FROM ubuntu:15.04</span><br><span class="line">  ---&gt; d1b55fd07600</span><br><span class="line">  Step 2/4 : COPY . /app</span><br><span class="line">  ---&gt; 6e3fe23e82f3</span><br><span class="line">  Step 3/4 : RUN mkdir -p /app/conf/</span><br><span class="line">  ---&gt; Running in 3a9b550d957b</span><br><span class="line">  Removing intermediate container 3a9b550d957b</span><br><span class="line">  ---&gt; 038a1543c273</span><br><span class="line">  Step 4/4 : CMD python /app/app.py</span><br><span class="line">  ---&gt; Running in 9b56a922b87f</span><br><span class="line">  Removing intermediate container 9b56a922b87f</span><br><span class="line">  ---&gt; 58866642a2af</span><br><span class="line">  Successfully built 58866642a2af</span><br><span class="line">  Successfully tagged my-ubuntu:test</span><br></pre></td></tr></table></figure><p>查看镜像是否存在：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">  REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">  my-ubuntu           test                58866642a2af        5 minutes ago       131MB</span><br><span class="line">  ubuntu              15.04               d1b55fd07600        2 years ago         131MB</span><br></pre></td></tr></table></figure><p>查看镜像构建详情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker history 58866642a2af</span><br><span class="line">  </span><br><span class="line">  IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">58866642a2af        49 seconds ago      /bin/sh -c #(nop)     CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;pyth…   0B                  </span><br><span class="line">038a1543c273        51 seconds ago      /bin/sh -c mkdir -p    /app/conf/                  0B                  </span><br><span class="line">6e3fe23e82f3        53 seconds ago      /bin/sh -c #(nop)    COPY dir:3f69c750361eacc36…   101B                </span><br><span class="line">d1b55fd07600        2 years ago         /bin/sh -c #(nop)    CMD [&quot;/bin/bash&quot;]             0B                  </span><br><span class="line">&lt;missing&gt;           2 years ago         /bin/sh -c sed -i    &apos;s/^#\s*\(deb.*universe\)$…   1.88kB              </span><br><span class="line">&lt;missing&gt;           2 years ago         /bin/sh -c echo    &apos;#!/bin/sh&apos; &gt; /usr/sbin/poli…   701B                </span><br><span class="line">&lt;missing&gt;           2 years ago         /bin/sh -c #(nop)    ADD file:3f4708cf445dc1b53…   131MB</span><br></pre></td></tr></table></figure><p>我们看到<code>58866642a2af</code> <code>038a1543c273</code> <code>6e3fe23e82f3</code> 是刚刚创建的层，对应着Dockerfile文件中的每条指令。<code>d1b55fd07600</code>是基础镜像的层，而<code>missing</code>则是以往他人在其他主机上构建的层，可以忽视。</p><p>当您使用<code>docker pull</code>从<code>registry</code>（镜像仓库）中下拉镜像时，每个镜像层都会单独下拉，并存储在Docker所在host的文件系统中，Linux主机上通常是<code>/var/lib/docker</code>。您可以在此示例中看到这些镜像层被拉出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull ubuntu:15.04</span><br><span class="line">  15.04: Pulling from library/ubuntu</span><br><span class="line">  9502adfba7f1: Pull complete </span><br><span class="line">  4332ffb06e4b: Pull complete </span><br><span class="line">  2f937cc07b5f: Pull complete </span><br><span class="line">  a3ed95caeb02: Pull complete </span><br><span class="line">  Digest:      sha256:2fb27e433b3ecccea2a14e794875b086711f5d49953ef173d8a03e8707f1510   f</span><br><span class="line">  Status: Downloaded newer image for ubuntu:15.04</span><br></pre></td></tr></table></figure><p>下拉的镜像层存储在<code>/var/lib/docker/&lt;storage-driver&gt;/</code>目录中，本例使用的存储驱动是<code>overlay2</code>，Docker version &gt; 1.10的版本，每层的目录名称与图层ID不对应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /var/lib/docker/overlay2/</span><br><span class="line">  drwx------. 4 root root     55 Jan 12 10:19    1e72c036bc24730abff4e3eed803c5d9c3ba67d61cc4dc0da62e880a5b23d7a9</span><br><span class="line">  drwx------. 4 root root     55 Jan 12 10:14      1fd044fc33c05db1b7fddf37992788befb6e5bd5dfa6ab0f4a72f281d68b5d8c</span><br><span class="line">  drwx------. 4 root root     55 Jan 12 10:20      2205c9e9efbd435b968dba2beb2390e2ddc49b5cd4efedae5a6a08a5a6d2634b</span><br><span class="line">  drwx------. 4 root root     55 Jan 12 10:18      25e720a5f2d95330556d5f99268217045654002d0c47cc77342342c2ba4af226</span><br><span class="line">  drwx------. 4 root root     55 Jan 12 10:18      277b95e43bbeb2f13ec6b7dd636b774d5e9ea56bad1414c6f1fe6c3178970172</span><br></pre></td></tr></table></figure></li><li><p>容器层</p><p>容器和镜像之间的主要区别在于顶部可写层，所有对容器的操作：对文件的修改和添加，都是在可写层进行操作的（写时复制CoW策略），<code>low-level</code>的镜像层不会更改。若将启动的容器进行删除，那么所有的操作将不被保留。<br>若以同一个镜像启动多个容器，则底层的镜像层是公共的层，为所有容器共用，对应每个容器有各自的可写层。对容器文件的修改保存均在容器层。对于不同的容器，容器层的数据不可共享，若想共享数据，可采用<code>docker volume</code>存储。针对该存储方案，由于内容较多，将单独作为一个章节进行介绍。</p><p><img src="/images/sharing-layers.jpg" alt></p><p>当启动一个容器，启动容器时，会在容器层的顶部添加一个体积比较小的可写容器层。容器对文件系统所做的任何更改都存储在此处。Docker的host主机文件系统中对应的容器层存储路径<code>/var/lib/docker/containers</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /var/lib/docker/containers</span><br><span class="line">drwx------. 4 root root 165 Jan 12 10:25    025030ca0a6d5383346d4cf5471108e5cfad22d74c3411a606baf3a902c99a28</span><br><span class="line">drwx------. 4 root root 165 Jan 12 10:26    0a19a162a971fb9364907e9d2e8d39baf47d588d9e18fc6c47f16f4bca56d569</span><br><span class="line">drwx------. 4 root root 237 Jan 12 10:25    1058890a8138eafaf5b7d84d3d708c0169fcba024e27697c01952465d0fdb78a</span><br><span class="line">drwx------. 4 root root 165 Jan 12 10:25    152da522924bf4ebebf960c3f93897f7d582f53ba98239922bf56baec7876eea</span><br><span class="line">drwx------. 4 root root 165 Jan 12 10:25    1ee87d5bc8e9a58d137cbe3f98e5fd85c7ac360e03de77d69e5fa27d315fb509</span><br></pre></td></tr></table></figure></li></ul><h4 id="写时复制（CoW）策略"><a href="#写时复制（CoW）策略" class="headerlink" title="写时复制（CoW）策略"></a>写时复制（CoW）策略</h4><p>写时复制（CoW）是一种共享和复制文件的策略。如果要读取或要修改的文件或目录存在于镜像中的<code>low-level</code>层（镜像层），若对该文件进行读访问，则它只需使用镜像层中的现有文件。 如果第一次添加或修改此文件时（比如：构建镜像或运行容器时），文件将被复制到该容器层（可写层）并进行修改。容器未更改的任何文件都不会复制到此可写层，意味着可写层尽可能小。这种策略保证了容器文件系统以及I/O操作的最小化。</p><p>对于aufs，overlay和overlay2存储驱动，写时复制操作遵循以下顺序：</p><ol><li>在镜像层中搜索要修改的文件。该过程从最新层开始，一次一层地向下移动到基础镜像层。找到结果后，会将它们复制到缓存中以加快将来的操作。</li><li><code>copy_up</code>对找到的文件的第一个副本执行操作，以将文件复制到容器的可写层。</li><li>对此文件副本进行任何修改，将保存在容器层，后续的操作将值针对该副本进行，对于镜像层的该文件对于容器来说，是不可见的。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Docker数据存储&quot;&gt;&lt;a href=&quot;#Docker数据存储&quot; class=&quot;headerlink&quot; title=&quot;Docker数据存储&quot;&gt;&lt;/a&gt;Docker数据存储&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在Docker中，有两种方式对数据进行存储：&lt;co
      
    
    </summary>
    
      <category term="运维" scheme="http://172.104.32.215/categories/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="docker" scheme="http://172.104.32.215/categories/%E8%BF%90%E7%BB%B4/docker/"/>
    
    
      <category term="docker" scheme="http://172.104.32.215/tags/docker/"/>
    
      <category term="storage" scheme="http://172.104.32.215/tags/storage/"/>
    
  </entry>
  
  <entry>
    <title>Centos搭建Docker私有仓库, Registry</title>
    <link href="http://172.104.32.215/2018/09/13/private-registry-docker/"/>
    <id>http://172.104.32.215/2018/09/13/private-registry-docker/</id>
    <published>2018-09-13T13:47:14.000Z</published>
    <updated>2019-03-25T05:50:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于docker的安装：<br><a href="http://www.weshzhu.com/2019/01/03/binary-install-docker-ce-on-centos7/" target="_blank" rel="noopener">CENTOS7二进制安装DOCKER-CE</a><br><a href="http://www.weshzhu.com/2019/03/25/install-docker-yum/" target="_blank" rel="noopener">CENTOS7 安装DOCKER-CE，并且配置 ALIYUN 加速</a></p><ol><li><p>覆盖掉目录/etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem （<strong>对于刚拿到的系统，一定要先备份，切记！本教程适用于 循环创建Docker支持https的私有仓库</strong>）<br> cp /home/zsd/tls-ca-bundle.pem /etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem</p></li><li><p>修改openssl.cnf文件<br> vi /etc/pki/tls/openssl.cnf<br> 在[v3_ca]下面添加 subjectAltName = IP:192.168.0.11</p></li><li><p>openssl生成私有证书<br> openssl req [-subj “/C=CN/ST=BeiJing/L=Dongcheng/CN=192.168.0.11”] -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout registry.key -out registry.crt<br> openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout registry.key -out registry.crt</p></li><li><p>将生成证书内容追加到该服务器上的证书存放目录的内置信任的证书<br> cat /certs/registry.crt &gt;&gt; /etc/pki/tls/certs/ca-bundle.crt</p></li><li><p>重启docker<br> systemctl restart docker</p></li><li><p>运行registry<br> docker run -d -p 443:443 –name registry -v /deploy/certs:/certs -e REGISTRY_HTTP_ADDR=0.0.0.0:443 -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/registry.crt -e REGISTRY_HTTP_TLS_KEY=/certs/registry.key registry:2</p></li><li><p>push镜像到registry<br> docker push 192.168.0.11/nginx<br> 常见错误<br> a. Get <a href="https://192.168.0.11/v2/" target="_blank" rel="noopener">https://192.168.0.11/v2/</a>: x509: cannot validate certificate for 192.168.0.11 because it doesn’t contain any IP SANs  未操作第4步<br> b. Get https://<ipaddress>/v2/: x509: certificate signed by unknown authority  #未操作第6步</ipaddress></p></li></ol><p>具体教程可参考<a href="http://blog.csdn.net/zsd498537806/article/details/79290732" target="_blank" rel="noopener">x509: cannot validate certificate because of not containing any IP SANs</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于docker的安装：&lt;br&gt;&lt;a href=&quot;http://www.weshzhu.com/2019/01/03/binary-install-docker-ce-on-centos7/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CENTOS7二进
      
    
    </summary>
    
      <category term="运维" scheme="http://172.104.32.215/categories/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="docker" scheme="http://172.104.32.215/categories/%E8%BF%90%E7%BB%B4/docker/"/>
    
    
      <category term="docker" scheme="http://172.104.32.215/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker中启动jenkins容器，并在jenkins中使用docker 命令，解决docker command not found</title>
    <link href="http://172.104.32.215/2018/03/22/jenkins-docker-command-not-found/"/>
    <id>http://172.104.32.215/2018/03/22/jenkins-docker-command-not-found/</id>
    <published>2018-03-21T20:04:07.000Z</published>
    <updated>2019-03-21T12:13:00.218Z</updated>
    
    <content type="html"><![CDATA[<p>首先，制作支持docker的jenkins镜像，基础镜像是<code>jenkins:2.60.3</code><br>参考<a href="https://container-solutions.com/running-docker-in-jenkins-in-docker/" target="_blank" rel="noopener">Running Docker in Jenkins (in Docker)</a></p><p>编辑Dockerfile，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM jenkins:2.60.3</span><br><span class="line"></span><br><span class="line">USER root</span><br><span class="line">RUN echo &apos;&apos; &gt; /etc/apt/sources.list.d/jessie-backports.list \</span><br><span class="line">  &amp;&amp; echo &quot;deb http://mirrors.aliyun.com/debian jessie main contrib non-free&quot; &gt; /etc/apt/sources.list \</span><br><span class="line">  &amp;&amp; echo &quot;deb http://mirrors.aliyun.com/debian jessie-updates main contrib non-free&quot; &gt;&gt; /etc/apt/sources.list \</span><br><span class="line">  &amp;&amp; echo &quot;deb http://mirrors.aliyun.com/debian-security jessie/updates main contrib non-free&quot; &gt;&gt; /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">RUN apt-get update       &amp;&amp; apt-get install -y sudo       &amp;&amp; apt-get install -y libltdl7       &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">RUN echo &quot;jenkins ALL=NOPASSWD: ALL&quot; &gt;&gt; /etc/sudoers</span><br><span class="line"></span><br><span class="line">USER jenkins</span><br><span class="line">COPY plugins.txt /usr/share/jenkins/plugins.txt</span><br><span class="line">RUN /usr/local/bin/plugins.sh /usr/share/jenkins/plugins.txt</span><br></pre></td></tr></table></figure></p><p>出现在执行docker命令时报：<code>docker: error while loading shared libraries: libltdl.so.7: cannot open shared object file: No such file or directory</code>错误<a href="https://www.cnblogs.com/leolztang/p/6934694.html" target="_blank" rel="noopener">解决办法，参考</a><br>加入如下代码后，问题解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RUN echo &apos;&apos; &gt; /etc/apt/sources.list.d/jessie-backports.list \</span><br><span class="line">  &amp;&amp; echo &quot;deb http://mirrors.aliyun.com/debian jessie main contrib non-free&quot; &gt; /etc/apt/sources.list \</span><br><span class="line">  &amp;&amp; echo &quot;deb http://mirrors.aliyun.com/debian jessie-updates main contrib non-free&quot; &gt;&gt; /etc/apt/sources.list \</span><br><span class="line">  &amp;&amp; echo &quot;deb http://mirrors.aliyun.com/debian-security jessie/updates main contrib non-free&quot; &gt;&gt; /etc/apt/sources.list</span><br></pre></td></tr></table></figure></p><p>预先安装的插件，放入plugins.txt文件中，也可以部署jenkins后，手动安装插件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">scm-api:latest</span><br><span class="line">git-client:latest</span><br><span class="line">git:latest</span><br><span class="line">greenballs:latest</span><br></pre></td></tr></table></figure></p><p>启动jenkins容器，执行如下命令，启动jenkins容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -v /var/run/docker.sock:/var/run/docker.sock -v $(which docker):/usr/bin/docker -v $PWD:/var/jenkins_home -p 8080:8080 jenkins:v2.6</span><br></pre></td></tr></table></figure><p>注意挂载<code>-v /var/run/docker.sock:/var/run/docker.sock -v $(which docker):/usr/bin/docker</code>，才可以共享宿主机的docker资源<br>指定工作目录：<code>-v $PWD:/var/jenkins_home</code>，将当前目录作为jenkins的工作目录。<br>此时，可以通过ip:8080端口访问jenkins，按照提示一步一步进行。配置完后，就可以使用了。<br>首先，我们新建一个pipeline构建计划，Jenkinsfile内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&apos;Test&apos;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &apos;docker images&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>，执行立即构建，当执行pipeline中的<code>docker images</code>命令时，报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ docker images</span><br><span class="line">Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.37/images/json: dial unix /var/run/docker.sock: connect: permission denied</span><br></pre></td></tr></table></figure></p><p>这是jenkinsfile中的命令在访问宿主机的<code>unix:///var/run/docker.sock</code>守护进程时，权限不足。在jenkins中，执行pipeline的用户是jenkins，可以在pipelines中的docker命令前增加<code>sudo</code>，便成功执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[test_pipeline] Running shell script</span><br><span class="line">+ sudo docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">jenkins             v2.6.3              7c6cba7c8a03        18 minutes ago      705MB</span><br><span class="line">jenkins             v2.6                bb042102b598        3 hours ago         705MB</span><br><span class="line">jenkins             2.60.3              cd14cecfdb3a        2 days ago          696MB</span><br><span class="line">busybox             latest              22c2dd5ee85d        3 days ago          1.16MB</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先，制作支持docker的jenkins镜像，基础镜像是&lt;code&gt;jenkins:2.60.3&lt;/code&gt;&lt;br&gt;参考&lt;a href=&quot;https://container-solutions.com/running-docker-in-jenkins-in-docke
      
    
    </summary>
    
      <category term="运维" scheme="http://172.104.32.215/categories/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="docker" scheme="http://172.104.32.215/categories/%E8%BF%90%E7%BB%B4/docker/"/>
    
    
      <category term="docker" scheme="http://172.104.32.215/tags/docker/"/>
    
      <category term="jenkins" scheme="http://172.104.32.215/tags/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>精通Oracle SQL（第二版）读书笔记  -  第二章 SQL执行</title>
    <link href="http://172.104.32.215/2017/08/17/oracle-sql-seconds-notes-sec-2-sql-exec/"/>
    <id>http://172.104.32.215/2017/08/17/oracle-sql-seconds-notes-sec-2-sql-exec/</id>
    <published>2017-08-17T13:58:59.000Z</published>
    <updated>2019-03-25T06:00:05.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="精通Oracle-SQL（第二版）读书笔记"><a href="#精通Oracle-SQL（第二版）读书笔记" class="headerlink" title="精通Oracle SQL（第二版）读书笔记"></a>精通Oracle SQL（第二版）读书笔记</h1><h2 id="第二章-SQL执行"><a href="#第二章-SQL执行" class="headerlink" title="第二章 SQL执行"></a>第二章 SQL执行</h2><h3 id="数据库和数据库文件、实例等概念"><a href="#数据库和数据库文件、实例等概念" class="headerlink" title="数据库和数据库文件、实例等概念"></a>数据库和数据库文件、实例等概念</h3><blockquote><p><strong>数据库</strong> 归属于 数据库文件</p></blockquote><blockquote><p><strong>实  例</strong> 归属于内存结构，是由SGA(System Global Area)及一系列后台进程组成的。</p></blockquote><blockquote><p><strong>PGA</strong> 客户端进程是与服务器进程相关联的，每个服务器进程都会被分配一块私有的内存区域，称为程序共享区域或进程共享内存区域（Process Global Area）。</p></blockquote><blockquote><p><strong>SGA</strong> 包含共享池（库高速缓存）、数据库高速缓存。</p></blockquote><h3 id="SGA"><a href="#SGA" class="headerlink" title="SGA"></a>SGA</h3><h6 id="共享池"><a href="#共享池" class="headerlink" title="共享池"></a>共享池</h6><ol><li>存储解析后的SQL语句，不管有多少个用户想执行同样的SQL语句，Oracle都会只解析该语句一次，将其放在共享池中，共享。</li><li>Oracle 使用的系统参数，在一块被称为数据字典的区域。<h6 id="高速缓存区域"><a href="#高速缓存区域" class="headerlink" title="高速缓存区域"></a>高速缓存区域</h6></li></ol><ul><li>存储所有的数据库对象信息。</li></ul><h6 id="管理共享池："><a href="#管理共享池：" class="headerlink" title="管理共享池："></a>管理共享池：</h6><ul><li>共享池的内存大小是由限制的，需要通过最近最少使用（LRU）算法进行共享池内存的管理，即保留那些使用频繁以及最近使用的解析语句。</li></ul><h3 id="执行SQL语句"><a href="#执行SQL语句" class="headerlink" title="执行SQL语句"></a>执行SQL语句</h3><p><img src="http://img.blog.csdn.net/20170331085505286?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenNkNDk4NTM3ODA2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="执行SQL语句"></p><h3 id="绑定变量"><a href="#绑定变量" class="headerlink" title="绑定变量"></a>绑定变量</h3><ul><li>在SQL语句中，有时使用<strong>绑定变量</strong>比使用常量更节约SQL语句执行时间，因为:在使用了绑定变量时，即使改变了变量的值，Oracle还是可以使用共享池的该SQL语句。</li></ul><blockquote><p>   SQL&gt; varible v_dept number  #定义变量 v_dept 为 number 类型</p></blockquote><blockquote><pre><code>SQL&gt; exec : v_dept = 10</code></pre></blockquote><blockquote><p>   SQL&gt; SELECT * FROM employees WHERE departent_id = :v_dept;    </p></blockquote><h3 id="锁存器"><a href="#锁存器" class="headerlink" title="锁存器"></a>锁存器</h3><ul><li>锁存器是为了Oracle读取存在库高速还粗或者其他内存结构中的信息时必须获得的一种锁，其他回话必须等待，锁存器是串行的。<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3></li><li><p>一个序列化组件，阻止多个线程同时访问一个共享结构，与锁存器相比，互斥锁的优点：</p><pre><code>**1.** 占内存少，且可快速获取和释放；**2.** 可直接修改游标的互斥锁引用计数，避免为已经打开的游标获取库高速缓存锁。</code></pre><h3 id="SGA缓冲区缓存"><a href="#SGA缓冲区缓存" class="headerlink" title="SGA缓冲区缓存"></a>SGA缓冲区缓存</h3><p><img src="http://img.blog.csdn.net/20170331085311877?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenNkNDk4NTM3ODA2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="SGA缓冲区缓存"></p></li><li><p><strong>块:</strong> Oracle进行操作的最小单位。典型的块大小：4KB，8KB，16KB；这取决于操作系统。</p></li><li><p><strong>缓冲区缓存</strong></p></li></ul><p><img src="http://img.blog.csdn.net/20170331085413757?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenNkNDk4NTM3ODA2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="SGA缓冲区缓存空间管理"></p><ul><li>刷新（清空）共享池和缓冲区缓存<blockquote><p>SQL&gt; alter system flush buffer_cache;</p></blockquote></li></ul><blockquote><p>SQL&gt; alter system flush shared_pool;</p></blockquote><ul><li>硬解析的物理存取和软解析的逻辑读取，我们的目标是开发出能够更多重用共享池和缓冲区缓存中信息的代码。</li></ul><h3 id="查询转换"><a href="#查询转换" class="headerlink" title="查询转换"></a>查询转换</h3><ul><li>在查询通过了语法和权限的检查之后，查询就进入了转换为一系列的查询块的转换阶段（SELECT 关键字定义查询块）。</li><li>查询块嵌套在另一个查询块中或者以某种方式与另一个查询块相连结。查询转换的目的是确定如果改变查询的写法会不会提供更好的查询计划。<h5 id="查询块"><a href="#查询块" class="headerlink" title="查询块"></a>查询块</h5></li><li>查询块可以由 Oracle 自动生成系统名称，也可以通过 <strong>QB_NAME</strong> 提示命名。</li><li>可以在<strong>V$SQL_PLAN</strong>视图中查询所使用的查询块名称，即之前执行的 SQL 语句。<h5 id="视图合并-——-类型转换"><a href="#视图合并-——-类型转换" class="headerlink" title="视图合并 —— 类型转换"></a>视图合并 —— 类型转换</h5></li><li>视图合并是一种能将内嵌或存储式视图展开为能够独立分析或者与查询剩余部分合并成总体执行计划的独立查询块的转换。</li><li>阻止视图合并的情况：查询块中包含分析函数、聚合函数、集合运算（例：UNION 、 INTERSECT 、MINUS）、ORDER BY 子句或使用了ROWNUM。（但可以使用MERGE 提示来强制执行视图合并）<h5 id="子嵌套解嵌套——-类型转换"><a href="#子嵌套解嵌套——-类型转换" class="headerlink" title="子嵌套解嵌套—— 类型转换"></a>子嵌套解嵌套—— 类型转换</h5></li><li>子查询解嵌套与视图合并的相似之处在于子查询也是通过一个单独的查询块来表示的，它们的区别：位置不同，子查询位于WHERE 子句，由转换器执行的解嵌套审查。最典型的转换就是将子查询转换为表联接。<h5 id="联结消除-——-类型转换"><a href="#联结消除-——-类型转换" class="headerlink" title="联结消除 —— 类型转换"></a>联结消除 —— 类型转换</h5></li><li>Oracle 消除冗余表的两种情况<ol><li>存在主 —— 外键约束</li><li>外联接，即使没有任何主 —— 外键约束，如果想消除的表在联结列上具有唯一键约束，并且没有任何列出现在查询列表中，则这张表也是可以消除的。</li></ol></li><li>如果一张表没有出现在执行计划中，就是发生了联结消除转换。</li><li>限制<ol><li>如果在查询的任何地方引用了联结键，则不支持联结消除；</li><li>如果主外键约束包含多个列，则不支持联结消除。<h5 id="排序消除-——-类型转换"><a href="#排序消除-——-类型转换" class="headerlink" title="排序消除 —— 类型转换"></a>排序消除 —— 类型转换</h5></li></ol></li><li>与联结消除类似，排序消除也会移除不必要的运算，在这里不必要的运算就是排序。</li><li>优化器选择使用在 ORDEY BY 子句的列上的索引，因为索引本事就是按照排序后的顺序存储的，此时，会发生类似的类型转换。<h5 id="谓词推进（谓语即所谓的条件）"><a href="#谓词推进（谓语即所谓的条件）" class="headerlink" title="谓词推进（谓语即所谓的条件）"></a>谓词推进（谓语即所谓的条件）</h5></li><li>谓词推进就是将谓词从一个内含查询块中应用到不可合并的查询块中，目的是允许索引的使用或让其他数据集筛选能够在查询中尽早的进行。</li><li>如果可以将谓词推进到不可合并查询块中尽早的执行，再剩下的执行计划中所需要抓取的数据就会更少。<h5 id="使用物化视图进行查询重写"><a href="#使用物化视图进行查询重写" class="headerlink" title="使用物化视图进行查询重写"></a>使用物化视图进行查询重写</h5></li><li>查询重写的前提是某个查询被保存为物化视图。转换器重写该查询以使用预先计算好的物化视图数据而不需要执行当前查询的转换。</li><li>物化视图与普通视图的区别是：查询已经执行，并将查询结果保存在了一张表中。也就是说，所有的确定执行计划、执行查询以及收集所有数据的工作已经完成，当同样的查询再次发起时就不需要再做一遍了。</li></ul><h5 id="确定执行计划"><a href="#确定执行计划" class="headerlink" title="确定执行计划"></a>确定执行计划</h5><ul><li>执行计划定义：就是Oracle访问查询所使用的对象并返回相应结果数据将会采用的一系列的步骤。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;精通Oracle-SQL（第二版）读书笔记&quot;&gt;&lt;a href=&quot;#精通Oracle-SQL（第二版）读书笔记&quot; class=&quot;headerlink&quot; title=&quot;精通Oracle SQL（第二版）读书笔记&quot;&gt;&lt;/a&gt;精通Oracle SQL（第二版）读书笔记&lt;/
      
    
    </summary>
    
      <category term="Oracle" scheme="http://172.104.32.215/categories/Oracle/"/>
    
    
      <category term="Oracle" scheme="http://172.104.32.215/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>精通Oracle SQL（第二版）读书笔记   -  第一章 SQL核心</title>
    <link href="http://172.104.32.215/2016/12/05/oracle-sql-second-version-note/"/>
    <id>http://172.104.32.215/2016/12/05/oracle-sql-second-version-note/</id>
    <published>2016-12-05T13:52:54.000Z</published>
    <updated>2019-03-25T05:57:00.548Z</updated>
    
    <content type="html"><![CDATA[<p>racle SQL（第二版）读书笔记</p><h2 id="第一章-SQL核心"><a href="#第一章-SQL核心" class="headerlink" title="第一章 SQL核心"></a>第一章 SQL核心</h2><h3 id="数据库接口"><a href="#数据库接口" class="headerlink" title="数据库接口"></a>数据库接口</h3><blockquote><p>1.数据库接口:<br>Oracle数据库的本地接口界面是<strong>OCI</strong>,<strong>OCI</strong> 将由 <strong>Oracle内核</strong>传递而来的查询语句发送到数据库。其他语言对应的接口：<em>Oracle JDBC-OCI、ODD.Net、Oracle 预编译器、Oracle ODBC以及Oracle C++ 调用接口OCCI驱动</em>。</p></blockquote><h3 id="SQL-Plus"><a href="#SQL-Plus" class="headerlink" title="SQL*Plus"></a>SQL*Plus</h3><blockquote><p>配置：$ORACLE_HOME/network/admin/tnsnames.ora 文件中登记想要连接的数据库。</p></blockquote><h3 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h3><blockquote><ul><li>sqlplus /nolog: 启动sqlplus但不显示登录到数据库后的提示。</li></ul></blockquote><blockquote><ul><li>help index： 显示可用的命令</li></ul></blockquote><blockquote><ul><li>help set： 用来定制工作环境最基本的命令，但退出sqlplus或者关闭时，这些设置命令不会被保存。可在login.sql文件中修改sqlplus环境设置。</li></ul></blockquote><h3 id="在login-sql文件中修改配置"><a href="#在login-sql文件中修改配置" class="headerlink" title="在login.sql文件中修改配置"></a>在login.sql文件中修改配置</h3><blockquote><p>在sql* plus启动时默认读取的两个文件，1.<strong>$ORACLE_HOME/sqlplus/admin</strong> 目录下的 <strong>glogin.sql</strong>和<strong>login.sql</strong> 文件。其中，<strong>login.sql</strong>中所有命令的优先级比glogin.sql高。Oracle log之后，启动sqlplus和在sqlplus中运行connect都会同时读取这两个文件。</p></blockquote><h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><blockquote><p>在sql<em> plus中执行的是两种命令：<strong>sql语句</strong> 和 **SQL </em> Plus命令**</p></blockquote><blockquote><p>SQL语句用<strong>；</strong> 和 <strong>/</strong> 结束输入</p></blockquote><ul><li><ol><li>可在命令后和另起一行使用；</li></ol></li><li><ol start="2"><li>/只能在下行中被识别。<blockquote><p>sqlplus缓冲区<br>sqlplus执行 <em>.sql 文件方式：1.直接输入 </em>.sql,2.输入@或者START *，可以省略后缀。</p></blockquote></li></ol></li></ul><h3 id="五大核心SQL语句-SELECT-INSERT-UPDATE-DELETE-MERGE"><a href="#五大核心SQL语句-SELECT-INSERT-UPDATE-DELETE-MERGE" class="headerlink" title="五大核心SQL语句(SELECT, INSERT, UPDATE, DELETE, MERGE)"></a>五大核心SQL语句(SELECT, INSERT, UPDATE, DELETE, MERGE)</h3><h4 id="1-SELECT-语句"><a href="#1-SELECT-语句" class="headerlink" title="1. SELECT 语句"></a>1. SELECT 语句</h4><h5 id="Oracle基于查询成本的优化器-Cost-Based-Optimizer-CBO-用来产生实际的执行计划。"><a href="#Oracle基于查询成本的优化器-Cost-Based-Optimizer-CBO-用来产生实际的执行计划。" class="headerlink" title="Oracle基于查询成本的优化器(Cost-Based Optimizer,CBO)用来产生实际的执行计划。"></a>Oracle基于查询成本的优化器(Cost-Based Optimizer,CBO)用来产生实际的执行计划。</h5><h5 id="select语句"><a href="#select语句" class="headerlink" title="- select语句"></a>- select语句</h5><blockquote><p>处理过程中首先处理的是<strong>From</strong>子句，多个<strong>From</strong>则每个步骤想象成一个临时数据集，每经过一个<strong>FROM</strong>，则进行一步筛选，得最终结果数据集。</p></blockquote><h5 id="From子句"><a href="#From子句" class="headerlink" title="- From子句"></a>- From子句</h5><blockquote><p>子句可以包含表、视图、物化视图、分区或者子分区。处理联结时：交叉联结（笛卡尔乘积）、内联结、外联结。</p></blockquote><h5 id="HAVING子句"><a href="#HAVING子句" class="headerlink" title="- HAVING子句"></a>- HAVING子句</h5><blockquote><p>将分组汇总后的查询结果限定为只满足该条件的数据行。GROUP BY 和 HAVING 子句的位置可以互换，但是一般情况下GROUP BY 放在前面。</p></blockquote><h5 id="ORDER-BY子句"><a href="#ORDER-BY子句" class="headerlink" title="- ORDER BY子句"></a>- ORDER BY子句</h5><blockquote><p>Oracle必须在其他所有子句都执行完毕之后按指定的列进行排序结果集。</p></blockquote><h4 id="2-INSERT-语句"><a href="#2-INSERT-语句" class="headerlink" title="2. INSERT 语句"></a>2. INSERT 语句</h4><h5 id="Insert语句可以向表、分区或者视图中添加行，可单表或者多表插入。"><a href="#Insert语句可以向表、分区或者视图中添加行，可单表或者多表插入。" class="headerlink" title="Insert语句可以向表、分区或者视图中添加行，可单表或者多表插入。"></a>Insert语句可以向表、分区或者视图中添加行，可单表或者多表插入。</h5><pre><code>INSERT ALL WHEN 条件1 THEN INTO table1           WHEN 条件2 THEN INTO table2           WHEN 条件3 THEN INTO table3            ...           SELECT ** FROM table4;</code></pre><blockquote><p>当指定<strong>ALL</strong>时，这个语句就会执行无条件的多表插入，可以用<strong>FIRST</strong>替换，此时指定按照<strong>WHEN</strong>子句在语句中的顺序进行判断    。</p></blockquote><h4 id="3-UPDATE-语句"><a href="#3-UPDATE-语句" class="headerlink" title="3. UPDATE 语句"></a>3. UPDATE 语句</h4><h5 id="该语法由-UPDATE、SET、WHERE-组成"><a href="#该语法由-UPDATE、SET、WHERE-组成" class="headerlink" title="该语法由 UPDATE、SET、WHERE 组成"></a>该语法由 <strong>UPDATE、SET、WHERE</strong> 组成</h5><h4 id="4-DELETE-语句"><a href="#4-DELETE-语句" class="headerlink" title="4. DELETE 语句"></a>4. DELETE 语句</h4><h5 id="由-DELETE、WHERE、FROM-组成"><a href="#由-DELETE、WHERE、FROM-组成" class="headerlink" title="由 DELETE、WHERE、FROM 组成"></a>由 DELETE、WHERE、FROM 组成</h5><h4 id="5-MERGE-语句"><a href="#5-MERGE-语句" class="headerlink" title="5. MERGE 语句"></a>5. MERGE 语句</h4><h5 id="MERGE-语句可以按条件获取要更新或者插入到表中的数据行，然后从-1-个或者多个源头对表进行更新或插入行。"><a href="#MERGE-语句可以按条件获取要更新或者插入到表中的数据行，然后从-1-个或者多个源头对表进行更新或插入行。" class="headerlink" title="MERGE 语句可以按条件获取要更新或者插入到表中的数据行，然后从 1 个或者多个源头对表进行更新或插入行。"></a>MERGE 语句可以按条件获取要更新或者插入到表中的数据行，然后从 1 个或者多个源头对表进行更新或插入行。</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;racle SQL（第二版）读书笔记&lt;/p&gt;
&lt;h2 id=&quot;第一章-SQL核心&quot;&gt;&lt;a href=&quot;#第一章-SQL核心&quot; class=&quot;headerlink&quot; title=&quot;第一章 SQL核心&quot;&gt;&lt;/a&gt;第一章 SQL核心&lt;/h2&gt;&lt;h3 id=&quot;数据库接口&quot;&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="Oracle" scheme="http://172.104.32.215/tags/Oracle/"/>
    
  </entry>
  
</feed>
