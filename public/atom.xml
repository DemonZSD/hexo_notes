<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Weshzhu Blogs</title>
  
  <subtitle>weshzhu</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://172.104.32.215/"/>
  <updated>2019-03-21T11:41:49.289Z</updated>
  <id>http://172.104.32.215/</id>
  
  <author>
    <name>Weshzhu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python 多线程锁机制介绍</title>
    <link href="http://172.104.32.215/2019/03/21/python-mulit-thread/"/>
    <id>http://172.104.32.215/2019/03/21/python-mulit-thread/</id>
    <published>2019-03-21T15:56:07.000Z</published>
    <updated>2019-03-21T11:41:49.289Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><ul><li>说明：</li></ul><p>对共享内存（资源），进行加锁，释放锁。保证同一时间，只有一个线程对共享资源进行操作。即保证了对共享资源的原子操作。</p><ul><li>使用：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">_lock = threading.lock() # 定义锁 _local</span><br><span class="line"></span><br><span class="line">_lock.accquire()  # 获取锁</span><br><span class="line"># TODO do something</span><br><span class="line">do_somthing(share_var)   # 操作共享资源</span><br><span class="line">_lock.release()  #释放锁</span><br></pre></td></tr></table></figure><ul><li><p>缺点：</p><p>死锁</p><p>当有多个共享资源（比如：<code>R_A</code>, <code>R_B</code>），多个线程（比如：<code>T_A</code>, <code>T_B</code>），每个线程都需要操作共享资源。假如线程 <code>T_A</code> 已经获取了共享资源 <code>R_A</code>，<code>T_B</code> 获取了共享资源 <code>R_B</code> ， 而线程 <code>T_A</code> 等待 <code>T_B</code> 释放共享资源 <code>R_B</code> 。 同时，线程 <code>T_B</code> 等待 <code>T_A</code> 释放共享资源 <code>R_A</code> ，此时就陷入死锁状态。</p></li></ul><h3 id="RLock"><a href="#RLock" class="headerlink" title="RLock"></a>RLock</h3><ul><li><p>说明：</p><p>RLock 其实叫做“Reentrant Lock”，就是可以重复进入的锁，也叫做“递归锁”。这种锁对比 <code>Lock</code> 有是四个特点：</p><ol><li>谁获取谁释放。如果线程A获取锁，线程B无法释放这个锁，只有A可以释放；而 <code>Lock</code> 锁，可以被另外一个线程所释放。</li><li>同一线程可以多次获取到该锁，即可以acquire多次；</li><li>如果使用RLock，那么acquire和release必须成对出现。acquire多少次就必须release多少次，只有最后一次release才能改变RLock的状态为unlocked）</li><li>相对 <code>Rlock</code> ， <code>Lock</code> 速度更快。</li></ol></li><li><p>使用：</p><p>使用 <code>Rlock</code> 锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import threading  </span><br><span class="line">rLock = threading.RLock()  #RLock对象  </span><br><span class="line">rLock.acquire()  </span><br><span class="line">rLock.acquire() #在同一线程内，程序不会堵塞。  </span><br><span class="line">rLock.release()  </span><br><span class="line">rLock.release()</span><br></pre></td></tr></table></figure></li></ul><p>  使用 <code>Lock</code> 锁：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import threading  </span><br><span class="line">lock = threading.Lock() #Lock对象  </span><br><span class="line">lock.acquire()  </span><br><span class="line">lock.acquire()  #产生了死琐。  </span><br><span class="line">lock.release()  </span><br><span class="line">lock.release()</span><br></pre></td></tr></table></figure><ul><li>缺点：</li></ul><h3 id="semaphore（信号量）"><a href="#semaphore（信号量）" class="headerlink" title="semaphore（信号量）"></a>semaphore（信号量）</h3><ul><li><p>说明：</p><p>信号量是由操作系统管理的一个内部的数据结构，用于表示共享资源当前支持有多少并发线程进行操作。当信号量为<strong>负值</strong>时，那么所有想获取共享资源的线程被挂起，直到有线程释放信号量，信号量的值变成<strong>非负值</strong>时。</p><p>本质上，信号量就是一个计数器，当计数器的值为 <strong>非负值</strong> 时， 通知其他线程，可以对共享资源进行竞争。当计数器的值为 <strong>负值</strong> 时，所有待获取共享资源的线程挂起状态。</p></li></ul><ul><li><p>使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">semaphore = threading.Semaphore(0)</span><br><span class="line"></span><br><span class="line"># Thread1:</span><br><span class="line">def thread1_method():</span><br><span class="line">    semaphore.acquire()  # 线程1 对信号量进行获取操作</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Thread2:</span><br><span class="line">def thread2_method():</span><br><span class="line">  semaphore.release()  # 线程2 对信号量进行释放操作，可以提高计数器</span><br></pre></td></tr></table></figure></li></ul><p>  信号量的 release() 可以对计数器加 1 操作。然后通知其他的线程，如果信号量的计数器到了0，就会阻塞 acquire() 方法，直到得到另一个线程的release()操作，通知。如果信号量的计数器大于0，就会对这个值 -1 然后分配资源。</p><ul><li><p>缺点：</p><p>导致死锁</p><p>有多个线程（比如：<code>t1</code> ， <code>t2</code>），竞争多个信号量（比如：<code>s1</code> , <code>s2</code>）。 假如，现在有一个线程 <code>t1</code> 先等待信号量 <code>s1</code> ，然后等待信号量 <code>s2</code> ，而线程 <code>t2</code> 会先等待信号量 <code>s2</code> ，然后再等待信号量 <code>s1</code> ，这样就可能会发生死锁，导致 <code>t1</code> 等待 <code>s2</code> ，但是 <code>t2</code> 在等待 <code>s1</code> 。</p></li></ul><h3 id="Condition-条件同步"><a href="#Condition-条件同步" class="headerlink" title="Condition - 条件同步"></a>Condition - 条件同步</h3><ul><li><p>说明：</p><p>当多个线程<strong>等待</strong>同一个条件时，当条件发生的时候，会通知所有等待该条件的线程。比如生产者消费者里的例子：在消费者线程里，只要篮子（共享资源）不满（条件），消费者线程通知生产者线程可以操作该篮子（共享资源）；在生产者线程里，只要篮子不空（条件），生产者线程通知消费者线程可操作该篮子。</p></li><li><p>使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line">condition = threading.Condition()</span><br><span class="line"></span><br><span class="line">#  生产者</span><br><span class="line">def thread1_method():</span><br><span class="line">  condition.acquire()</span><br><span class="line">  # 条件判断</span><br><span class="line">  if (condition_var == False)：  # 条件不满足       </span><br><span class="line">      condition.wait()  # 释放锁，线程挂起，等待被其他线程唤醒</span><br><span class="line">  </span><br><span class="line">  # TODO do something</span><br><span class="line"></span><br><span class="line">  condition.notify()  # 条件满足，通知其他线程</span><br><span class="line">  condition.release()  # 释放资源</span><br><span class="line"></span><br><span class="line"># 消费者</span><br><span class="line">def thread2_method():</span><br><span class="line">   </span><br><span class="line">  condition.accquire()</span><br><span class="line">  # 条件判断</span><br><span class="line">  if (condition_var == False)：  # 条件不满足       </span><br><span class="line">       condition.wait()  # 释放锁，线程挂起，等待被其他线程唤醒</span><br><span class="line"></span><br><span class="line">  # 条件满足</span><br><span class="line">  # TODO  do something</span><br><span class="line"></span><br><span class="line">  condition.notify()  # 条件满足，通知其他线程</span><br><span class="line">  condition.release()   # 释放资源</span><br></pre></td></tr></table></figure><p><code>wait</code> 方法释放内部所占用的琐，同时线程被挂起，直至接收到通知被唤醒或超时（如果提供了timeout参数的话）。当线程被唤醒并重新占有琐的时候，程序才会继续执行下去。</p><p><code>notify</code> 唤醒一个挂起的线程（如果存在挂起的线程）。注意：<code>notify()</code>方法不会释放所占用的琐。需要通过 <code>release()</code> 方法释放锁。</p></li></ul><ul><li>缺点：</li></ul><h3 id="Event-事件"><a href="#Event-事件" class="headerlink" title="Event - 事件"></a>Event - 事件</h3><ul><li>说明：</li><li><p>使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">event = threading.Event()</span><br></pre></td></tr></table></figure></li><li><p>缺点：</p></li></ul><p><strong>参考：</strong></p><ul><li><p><a href="https://python-parallel-programmning-cookbook.readthedocs.io/zh_CN/latest/chapter2/index.html" target="_blank" rel="noopener">基于线程的并行</a></p></li><li><p><a href="https://stackoverflow.com/questions/22885775/what-is-the-difference-between-lock-and-rlock" target="_blank" rel="noopener">What is the difference between Lock and RLock</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Lock&quot;&gt;&lt;a href=&quot;#Lock&quot; class=&quot;headerlink&quot; title=&quot;Lock&quot;&gt;&lt;/a&gt;Lock&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;说明：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对共享内存（资源），进行加锁，释放锁。保证同一时间，只有一个线程对共享资源进
      
    
    </summary>
    
    
      <category term="Python" scheme="http://172.104.32.215/tags/Python/"/>
    
      <category term="thread" scheme="http://172.104.32.215/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>gcr.io和quay.io拉取镜像失败</title>
    <link href="http://172.104.32.215/2019/03/21/pull-docker-images-failed/"/>
    <id>http://172.104.32.215/2019/03/21/pull-docker-images-failed/</id>
    <published>2019-03-21T11:17:18.000Z</published>
    <updated>2019-03-21T11:41:49.289Z</updated>
    
    <content type="html"><![CDATA[<p>k8s在使用编排（manifest）工具进行yaml文件启动pod时，会遇到官方所给例子中<code>spec.containers.image</code>包含：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">quay.io/coreos/example_</span><br><span class="line">gcr.io/google_containers/example_</span><br></pre></td></tr></table></figure></p><p>也就是说，从quay.io和gcr.io进行镜像拉取，我们知道，国内访问外网是被屏蔽了的。可以将其替换为 quay-mirror.qiniu.com 和 registry.aliyuncs.com</p><ul><li><p>例如<br>  <strong>下拉镜像</strong>：<code>quay.io/coreos/flannel:v0.10.0-s390x</code><br>  如果拉取较慢，可以改为：<code>quay-mirror.qiniu.com/coreos/flannel:v0.10.0-s390x</code></p><p>  <strong>下拉镜像</strong>：<code>gcr.io/google_containers/kube-proxy</code><br>  可以改为： <code>registry.aliyuncs.com/google_containers/kube-proxy</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;k8s在使用编排（manifest）工具进行yaml文件启动pod时，会遇到官方所给例子中&lt;code&gt;spec.containers.image&lt;/code&gt;包含：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
      <category term="运维" scheme="http://172.104.32.215/categories/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="docker" scheme="http://172.104.32.215/categories/%E8%BF%90%E7%BB%B4/docker/"/>
    
    
      <category term="docker" scheme="http://172.104.32.215/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker存储原理——介绍</title>
    <link href="http://172.104.32.215/2019/03/21/docker-storage/"/>
    <id>http://172.104.32.215/2019/03/21/docker-storage/</id>
    <published>2019-03-21T08:46:02.000Z</published>
    <updated>2019-03-21T11:41:49.289Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker数据存储"><a href="#Docker数据存储" class="headerlink" title="Docker数据存储"></a>Docker数据存储</h2><blockquote><p>在Docker中，有两种方式对数据进行存储：<code>docker volume</code>(存储卷) 和 <code>docker storage driver</code>（存储驱动），本文主要介绍<code>docker storage driver</code>存储驱动。</p></blockquote><p>准备工作：</p><p>OS: centos 7.4 (kernel version &gt; 3.10.514 )</p><p>Docker: docker-ce 18.03.1 ( <a href="http://www.weshzhu.com/2019/01/03/binary-install-docker-ce-on-centos7/" target="_blank" rel="noopener">docker-ce安装教程</a>)</p><h4 id="Docker-数据存储"><a href="#Docker-数据存储" class="headerlink" title="Docker 数据存储"></a>Docker 数据存储</h4><p>在了解<code>Docker storage driver</code>之前，我们先了解一下Docker如何存储容器数据和镜像数据。在Docker中数据分为镜像数据和容器数据，容器数据又包含容器可写层和<code>docker volume</code>存储。镜像数据是一种静态数据，存储了提供容器运行的程序、配置文件等。容器数据可以理解为动态 + 静态的数据（阅读本文后，可能有比较直观的理解），供容器运行使用。</p><p><img src="./container-layers.jpg" alt></p><p>如上图所示，容器层（high-level）是非常小的层，允许程序对该层读写操作；镜像层(low-level)包含了大部分的数据，并且是只读的。在镜像未启动时均是以镜像层存储在host主机上（存储路径：<code>/var/lib/docker/&lt;storage-driver&gt;/</code>）。以该镜像为基础，通过<code>docker run</code>启动一个或多个容器后，针对每个启动的容器会增加一层——可读写层（容器层）。</p><ul><li><p>镜像层<br>Docker镜像是由一系列的层（<code>layer</code>）构成，镜像的每个<code>layer</code>对应这个Dockerfile中的每条指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:15.04</span><br><span class="line">COPY . /app</span><br><span class="line">RUN mkdir -p /app/conf/</span><br><span class="line">CMD python /app/app.py</span><br></pre></td></tr></table></figure><p>通过<code>docker build -t</code>命令构建镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t my-ubuntu:test -f Dockerfile .</span><br><span class="line">  </span><br><span class="line">  Sending build context to Docker daemon  3.584kB</span><br><span class="line">  Step 1/4 : FROM ubuntu:15.04</span><br><span class="line">  ---&gt; d1b55fd07600</span><br><span class="line">  Step 2/4 : COPY . /app</span><br><span class="line">  ---&gt; 6e3fe23e82f3</span><br><span class="line">  Step 3/4 : RUN mkdir -p /app/conf/</span><br><span class="line">  ---&gt; Running in 3a9b550d957b</span><br><span class="line">  Removing intermediate container 3a9b550d957b</span><br><span class="line">  ---&gt; 038a1543c273</span><br><span class="line">  Step 4/4 : CMD python /app/app.py</span><br><span class="line">  ---&gt; Running in 9b56a922b87f</span><br><span class="line">  Removing intermediate container 9b56a922b87f</span><br><span class="line">  ---&gt; 58866642a2af</span><br><span class="line">  Successfully built 58866642a2af</span><br><span class="line">  Successfully tagged my-ubuntu:test</span><br></pre></td></tr></table></figure><p>查看镜像是否存在：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">  REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">  my-ubuntu           test                58866642a2af        5 minutes ago       131MB</span><br><span class="line">  ubuntu              15.04               d1b55fd07600        2 years ago         131MB</span><br></pre></td></tr></table></figure><p>查看镜像构建详情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker history 58866642a2af</span><br><span class="line">  </span><br><span class="line">  IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">58866642a2af        49 seconds ago      /bin/sh -c #(nop)     CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;pyth…   0B                  </span><br><span class="line">038a1543c273        51 seconds ago      /bin/sh -c mkdir -p    /app/conf/                  0B                  </span><br><span class="line">6e3fe23e82f3        53 seconds ago      /bin/sh -c #(nop)    COPY dir:3f69c750361eacc36…   101B                </span><br><span class="line">d1b55fd07600        2 years ago         /bin/sh -c #(nop)    CMD [&quot;/bin/bash&quot;]             0B                  </span><br><span class="line">&lt;missing&gt;           2 years ago         /bin/sh -c sed -i    &apos;s/^#\s*\(deb.*universe\)$…   1.88kB              </span><br><span class="line">&lt;missing&gt;           2 years ago         /bin/sh -c echo    &apos;#!/bin/sh&apos; &gt; /usr/sbin/poli…   701B                </span><br><span class="line">&lt;missing&gt;           2 years ago         /bin/sh -c #(nop)    ADD file:3f4708cf445dc1b53…   131MB</span><br></pre></td></tr></table></figure><p>我们看到<code>58866642a2af</code> <code>038a1543c273</code> <code>6e3fe23e82f3</code> 是刚刚创建的层，对应着Dockerfile文件中的每条指令。<code>d1b55fd07600</code>是基础镜像的层，而<code>missing</code>则是以往他人在其他主机上构建的层，可以忽视。</p><p>当您使用<code>docker pull</code>从<code>registry</code>（镜像仓库）中下拉镜像时，每个镜像层都会单独下拉，并存储在Docker所在host的文件系统中，Linux主机上通常是<code>/var/lib/docker</code>。您可以在此示例中看到这些镜像层被拉出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull ubuntu:15.04</span><br><span class="line">  15.04: Pulling from library/ubuntu</span><br><span class="line">  9502adfba7f1: Pull complete </span><br><span class="line">  4332ffb06e4b: Pull complete </span><br><span class="line">  2f937cc07b5f: Pull complete </span><br><span class="line">  a3ed95caeb02: Pull complete </span><br><span class="line">  Digest:      sha256:2fb27e433b3ecccea2a14e794875b086711f5d49953ef173d8a03e8707f1510   f</span><br><span class="line">  Status: Downloaded newer image for ubuntu:15.04</span><br></pre></td></tr></table></figure><p>下拉的镜像层存储在<code>/var/lib/docker/&lt;storage-driver&gt;/</code>目录中，本例使用的存储驱动是<code>overlay2</code>，Docker version &gt; 1.10的版本，每层的目录名称与图层ID不对应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /var/lib/docker/overlay2/</span><br><span class="line">  drwx------. 4 root root     55 Jan 12 10:19    1e72c036bc24730abff4e3eed803c5d9c3ba67d61cc4dc0da62e880a5b23d7a9</span><br><span class="line">  drwx------. 4 root root     55 Jan 12 10:14      1fd044fc33c05db1b7fddf37992788befb6e5bd5dfa6ab0f4a72f281d68b5d8c</span><br><span class="line">  drwx------. 4 root root     55 Jan 12 10:20      2205c9e9efbd435b968dba2beb2390e2ddc49b5cd4efedae5a6a08a5a6d2634b</span><br><span class="line">  drwx------. 4 root root     55 Jan 12 10:18      25e720a5f2d95330556d5f99268217045654002d0c47cc77342342c2ba4af226</span><br><span class="line">  drwx------. 4 root root     55 Jan 12 10:18      277b95e43bbeb2f13ec6b7dd636b774d5e9ea56bad1414c6f1fe6c3178970172</span><br></pre></td></tr></table></figure></li><li><p>容器层</p><p>容器和镜像之间的主要区别在于顶部可写层，所有对容器的操作：对文件的修改和添加，都是在可写层进行操作的（写时复制CoW策略），<code>low-level</code>的镜像层不会更改。若将启动的容器进行删除，那么所有的操作将不被保留。<br>若以同一个镜像启动多个容器，则底层的镜像层是公共的层，为所有容器共用，对应每个容器有各自的可写层。对容器文件的修改保存均在容器层。对于不同的容器，容器层的数据不可共享，若想共享数据，可采用<code>docker volume</code>存储。针对该存储方案，由于内容较多，将单独作为一个章节进行介绍。<br><img src="./sharing-layers.jpg" alt></p></li></ul><p>   当启动一个容器，启动容器时，会在容器层的顶部添加一个体积比较小的可写容器层。容器对文件系统所做的任何更改都存储在此处。Docker的host主机文件系统中对应的容器层存储路径<code>/var/lib/docker/containers</code></p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /var/lib/docker/containers</span><br><span class="line">drwx------. 4 root root 165 Jan 12 10:25    025030ca0a6d5383346d4cf5471108e5cfad22d74c3411a606baf3a902c99a28</span><br><span class="line">drwx------. 4 root root 165 Jan 12 10:26    0a19a162a971fb9364907e9d2e8d39baf47d588d9e18fc6c47f16f4bca56d569</span><br><span class="line">drwx------. 4 root root 237 Jan 12 10:25    1058890a8138eafaf5b7d84d3d708c0169fcba024e27697c01952465d0fdb78a</span><br><span class="line">drwx------. 4 root root 165 Jan 12 10:25    152da522924bf4ebebf960c3f93897f7d582f53ba98239922bf56baec7876eea</span><br><span class="line">drwx------. 4 root root 165 Jan 12 10:25    1ee87d5bc8e9a58d137cbe3f98e5fd85c7ac360e03de77d69e5fa27d315fb509</span><br></pre></td></tr></table></figure><h4 id="写时复制（CoW）策略"><a href="#写时复制（CoW）策略" class="headerlink" title="写时复制（CoW）策略"></a>写时复制（CoW）策略</h4><p>写时复制（CoW）是一种共享和复制文件的策略。如果要读取或要修改的文件或目录存在于镜像中的<code>low-level</code>层（镜像层），若对该文件进行读访问，则它只需使用镜像层中的现有文件。 如果第一次添加或修改此文件时（比如：构建镜像或运行容器时），文件将被复制到该容器层（可写层）并进行修改。容器未更改的任何文件都不会复制到此可写层，意味着可写层尽可能小。这种策略保证了容器文件系统以及I/O操作的最小化。</p><p>对于aufs，overlay和overlay2存储驱动，写时复制操作遵循以下顺序：</p><ol><li>在镜像层中搜索要修改的文件。该过程从最新层开始，一次一层地向下移动到基础镜像层。找到结果后，会将它们复制到缓存中以加快将来的操作。</li><li><code>copy_up</code>对找到的文件的第一个副本执行操作，以将文件复制到容器的可写层。</li><li>对此文件副本进行任何修改，将保存在容器层，后续的操作将值针对该副本进行，对于镜像层的该文件对于容器来说，是不可见的。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Docker数据存储&quot;&gt;&lt;a href=&quot;#Docker数据存储&quot; class=&quot;headerlink&quot; title=&quot;Docker数据存储&quot;&gt;&lt;/a&gt;Docker数据存储&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在Docker中，有两种方式对数据进行存储：&lt;co
      
    
    </summary>
    
      <category term="docker" scheme="http://172.104.32.215/categories/docker/"/>
    
    
      <category term="docker" scheme="http://172.104.32.215/tags/docker/"/>
    
      <category term="storage" scheme="http://172.104.32.215/tags/storage/"/>
    
  </entry>
  
</feed>
