<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Weshzhu Blogs</title>
  
  <subtitle>weshzhu</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://172.104.32.215/"/>
  <updated>2019-03-21T12:25:46.633Z</updated>
  <id>http://172.104.32.215/</id>
  
  <author>
    <name>Weshzhu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>docker网络驱动之--overlay网络</title>
    <link href="http://172.104.32.215/2019/03/22/docker-network-overlay/"/>
    <id>http://172.104.32.215/2019/03/22/docker-network-overlay/</id>
    <published>2019-03-21T20:23:46.000Z</published>
    <updated>2019-03-21T12:25:46.633Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>docker overlay</code>网络用于创建多个docker主机之间的分布式网络。该网络位于（覆盖）特定于主机的网络之上，可以将<code>swarm</code>集群服务和<code>containers</code>容器与<code>overlay</code>网络进行连接，使各个服务或者服务与容器之间进行通信。</p></blockquote><h4 id="创建或加入swarm服务"><a href="#创建或加入swarm服务" class="headerlink" title="创建或加入swarm服务"></a>创建或加入<code>swarm</code>服务</h4><p>在创建和使用<code>overlay</code>之前，必须初始化一个<a href="https://docs.docker.com/engine/swarm/" target="_blank" rel="noopener"><code>swarm</code></a>或者加入某个<code>swarm</code>:</p><ul><li><p>创建一个<code>swarm</code>集群服务</p><p>用法：<code>docker swarm init [OPTIONS]</code>，针对常用的<code>[OPTIONS]</code>介绍见下方表格：</p><p>参数说明</p><p>|参数|类型|默认值|说明|<br>|—–|—–|—–|—–|<br>|<code>--advertise-addr</code>| string ||多块网卡时对应多个IP地址时，需要指定|<br>|<code>--data-path-addr</code>|string||用于数据流量传输的IP地址或者网卡名称（例：<code>eth0</code>）|<br>|<code>--listen-addr</code>|node-addr|0.0.0.0:2377|监听地址|</p></li></ul><p>  <strong>示例：创建<code>swarm</code>服务</strong></p><p>  我们用两个节点进行演示，一个node既是管理节点，工作节点；一个node仅是工作节点：</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node1 : 192.168.0.190  (manager &amp; worker)</span><br><span class="line">node2 : 192.168.0.191 (worker)</span><br></pre></td></tr></table></figure><p>   <img src="/images/swarmcluster.png" alt="swarm架构"></p><ul><li><p>创建<code>swarm</code>集群服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm init --advertise-addr 192.168.0.190</span><br><span class="line">Swarm initialized: current node      (se5tsje7l9oibpsx54bbe7nuf) is now amanager.</span><br><span class="line">To add a worker to this swarm, run the following      command:</span><br><span class="line">  docker swarm join      --tokenSWMTKN-1-45ffvnn83wrl0aprynpcs0cogtg951kns  t fq  n7ok98hizonw9s-e5p7e5yjfit5tx6l1kp3e6d9      192.168.0.190:2377</span><br><span class="line">To add a manager to this swarm, run &apos;docker swarm      join-tokenmanager&apos; and follow the instructions.</span><br></pre></td></tr></table></figure></li></ul><pre><code>注意到执行初始化`swarm`语句时，会打印出其他node节点加 入该`swarm`的方式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join --token xxxx &lt;manager-ip&gt;:&lt;port&gt;</span><br></pre></td></tr></table></figure>可以将其保存到文档，以便于后续`swarm`Node的[join]   (https://docs.docker.   com/engine/reference/commandline/swarm_join/)。查看docker网络<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER                 SCOPE</span><br><span class="line">ba18dbad1160        bridge              bridge                 local</span><br><span class="line">58886c346808        docker_gwbridge     bridge                 local</span><br><span class="line">7966432ad37e        host                host                   local</span><br><span class="line">yryhkokko1tk        ingress             overlay                swarm</span><br><span class="line">d1ab833f3555        none                null                   local</span><br></pre></td></tr></table></figure>可以看到在docker网络中，新增了`ingress`和 `docker_gwbridge`网络。- `ingress`  一个名为ingress的覆盖网络，用于处理与`swarm`服务相关   的控制和数据流量。创建`swarm`服务时，如果不将其连接   到用户定义的覆盖网络，则默认情况下会连接到该   `ingress`网络  使用 `docker network inspect ingress`查看现有的   `ingress`网络。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect ingress</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;ingress&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;yryhkokko1tkpkhx0pf0e1zm3&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2019-01-08T17:05:50.511486192+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;swarm&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;overlay&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: null,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;10.255.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;10.255.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: true,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;ingress-sbox&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;ingress-endpoint&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;75df50d1f8228ff64d65a6801bc2a93e31de3f72adaec01e147abd266d3d64eb&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:0a:ff:00:03&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;10.255.0.3/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;</span><br><span class="line">            &quot;com.docker.network.driver.overlay.vxlanid_list&quot;: &quot;4096&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Peers&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;5e8427535708&quot;,</span><br><span class="line">                &quot;IP&quot;: &quot;192.168.0.190&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;42c5607b0c46&quot;,</span><br><span class="line">                &quot;IP&quot;: &quot;192.168.0.191&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>- `docker_gwbridge`  一个名为`docker_gwbridge`的桥接网络，它用于各个  `swarm`中，各个node节点进行通信的桥接网络。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect docker_gwbridge</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;docker_gwbridge&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;2c7254c25f765b28833668e060246a813d69b8936a5db1a8cd2bc7237dfc7df4&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2019-01-08T17:05:51.263715613+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: null,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.18.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.18.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;ingress-sbox&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;gateway_ingress-sbox&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;4f6821a4096104af4f04aea5caab7a5a3419a2b6469b31ea7a52f4c92b9023af&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.18.0.2/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;</span><br><span class="line">            &quot;com.docker.network.bridge.enable_icc&quot;: &quot;false&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.name&quot;: &quot;docker_gwbridge&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>增加工作（<code>worker</code>）节点</p><p>  将node2(192.168.0.191)加入到该<code>swarm</code>：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm join --token \</span><br><span class="line">  SWMTKN-1-45ffvnn83wrl0aprynpcs0cogtg951knstfqn7ok98hizonw9s-e5p7e50yjfit5tx6l1kp3e6d9  \</span><br><span class="line">  192.168.0.190:2377</span><br><span class="line"></span><br><span class="line">  This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure><p>  查看node</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker node ls</span><br><span class="line">  ID                            HOSTNAME             STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION</span><br><span class="line">  se5tsje7l9oibpsx54bbe7nuf *   host1                 Ready               Active              Leader              18.03.1-ce</span><br><span class="line">  timpbicei0sxbsuv9rq1625eh     host2                 Ready               Active                                  18.03.1-ce</span><br></pre></td></tr></table></figure></li></ul><pre><code>查看**工作节点**的docker网络<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker network ls </span><br><span class="line">  NETWORK ID          NAME                DRIVER                    SCOPE</span><br><span class="line">  e39a5d50e807        bridge              bridge                    local</span><br><span class="line">  2c7254c25f76        docker_gwbridge     bridge                    local</span><br><span class="line">  a284efd6e1f2        host                host                      local</span><br><span class="line">  yryhkokko1tk        ingress             overlay                   swarm</span><br><span class="line">  13bd88a34632        none                null                  local</span><br></pre></td></tr></table></figure></code></pre><h4 id="overlay网络"><a href="#overlay网络" class="headerlink" title="overlay网络"></a><code>overlay</code>网络</h4><ul><li><p>创建<code>overlay</code>网络</p><p>在创建<code>overlay</code>网络前，需要初始化或者加入<code>swarm</code>服务。即使可能后续不会使用<code>swarm</code>服务，也需要执行此操作。之后，您可以创建其他用户定义的覆盖网络。</p><p>要创建用于swarm服务的覆盖网络，请使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create -d overlay my-overlay</span><br></pre></td></tr></table></figure><p>要创建可由群集服务或独立容器用于与在其他Docker守护进程主机上运行的其他独立容器通信的<code>overlay</code>网络，必须添加<code>--attachable</code>标志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create -d overlay --attachable my-attachable-overlay</span><br></pre></td></tr></table></figure><p>在创建可以指定IP地址范围，子网，网关和其他选项。有关详细信息，请参阅docker network create –help</p></li><li><p><code>overlay</code>网络流量加密（不支持windows操作系统）</p><p>在<code>swarm</code>服务中的管理流量默认是通过<code>GCM-AES</code>加密算法进行加密。如果尝试对容器间的流量进行加密，在创建覆盖网络时添加<code>--opt encrypted</code>属性，Docker会在各个工作节点之间建立<code>IPSEC</code>隧道。但是通常加密解密操作需要消耗一定的性能，若将网络加密应用于生产环境，一定对该性能损耗进行评估。</p></li></ul><ul><li><p>自定义默认<code>ingress</code></p><p>Docker 17.05之后的版本，才支持用户修改默认<code>ingress</code>网络。如果自动选择的子网与网络上已存在的子网冲突，或者您需要自定义其他<code>low-level</code>底层网络设置（如MTU），则此功能非常有用。</p><ul><li><p>创建<code>ingress</code>网络</p><p>使用–ingress标志创建新的覆盖网络，以及要设置的自定义  选项。此示例将MTU设置为1200，将子网设置为10.11.0.0/16，并将网关设置为10.11.0.2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create \</span><br><span class="line">  --driver overlay \</span><br><span class="line">  --ingress \</span><br><span class="line">  --subnet=10.11.0.0/16 \</span><br><span class="line">  --gateway=10.11.0.2 \</span><br><span class="line">  --opt com.docker.network.driver.mtu=1200 \</span><br><span class="line">  my-ingress</span><br></pre></td></tr></table></figure><p>注意：您可以对<code>ingress</code>网络重新命名，但您只能拥有一个<code>ingress</code>网络。</p></li><li><p>删除<code>ingress</code>网络</p><p>如果现有服务有发布端口，则需要先删除这些服务，然后才能删除<code>ingress</code>网络。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker network rm ingress</span><br><span class="line"> </span><br><span class="line">  WARNING! Before removing the routing-mesh   network, make sure all the nodes</span><br><span class="line">  in your swarm run the same docker engine   version. Otherwise, removal may not</span><br><span class="line">  be effective and functionality of newly created   ingress networks will be</span><br><span class="line">  impaired.</span><br><span class="line">  Are you sure you want to continue? [y/N]</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>自定义<code>docker_gwbridge</code></p><p><code>docker_gwbridge</code>是一个虚拟网桥，将覆盖网络（包括<code>ingress</code>网络）连接到单个Docker守护程序的物理网络，它存在于Docker主机的内核中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ip addr | grep docker_gwbridge</span><br><span class="line">  docker_gwbridge: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;   mtu 1500 qdisc noqueue state UP </span><br><span class="line">    inet 172.18.0.1/16 brd 172.18.255.255 scope   global docker_gwbridge</span><br></pre></td></tr></table></figure></li></ul><ol><li><p>Stop Docker service</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl stop docker</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>删除<code>docker_gwbridge</code>网桥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ip link set  docker_gwbridge down</span><br><span class="line">$ ip link del dev docker_gwbridge</span><br></pre></td></tr></table></figure></li><li><p>启动Docker，但是不要初始化<code>swarm</code>或者加入任何<code>swarm</code>  服务网络</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start docker</span><br></pre></td></tr></table></figure></li><li><p>使用<code>docker network create</code>命令，使用自定义设置手动  创建或重新创建<code>docker_gwbridge</code>桥。此示例使用子网  10.11.0.0/16。有关可自定义选项的完整列表，请参阅[Bridge  驱动程序选项]  (<a href="https://docs.docker.com/engine/reference/commandline/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/</a>  network_create/#bridge-driver-options)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create  \</span><br><span class="line">  --subnet 10.11.0.0/16 \</span><br><span class="line">  --opt    com.docker.network.bridge.name=docker_gwbridge \</span><br><span class="line">  --opt com.docker.network.bridge.enable_icc=false  \</span><br><span class="line">  --opt    com.docker.network.bridge.enable_ip_masquerade=true \</span><br><span class="line">  docker_gwbridge</span><br></pre></td></tr></table></figure></li><li><p>初始化或加入<code>swarm</code>服务集群。由<code>docker_gwbridge</code>网桥已经存在，初始化时Docker不再创建它。</p></li></ol><h4 id="创建用于swarm服务的overlay网络"><a href="#创建用于swarm服务的overlay网络" class="headerlink" title="创建用于swarm服务的overlay网络"></a>创建用于<code>swarm</code>服务的<code>overlay</code>网络</h4><ul><li><p>在<code>overlay</code>网络上，暴露服务端口号</p><p>连接到同一覆盖网络的群集服务有效地将所有端口彼此暴露。对于可在服务外部访问的端口，必须使用<code>docker service create</code>或<code>docker service update</code>上的<code>-p</code>或<code>--publish</code>参数发布端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker service create</span><br></pre></td></tr></table></figure><p>默认情况下，发布端口的<code>swarm</code>服务使用路由网格(<code>routing mesh</code>)来实现。如果连接到当您连接到任何swarm节点上的已发布端口（无论它是否正在运行给定服务）时，您将被透明地重定向到正在运行该服务的worker。</p></li><li><p><code>swram</code>服务区（<code>swarm service</code>）绕过网格路由（<code>routing mesh</code>）</p><p>默认情况下，发布端口的<code>swarm</code>服务使用路由网格来实现负载均衡。 当您连接到任意一个<code>swarm</code>节点（工作节点和管理节点）上的已发布端口（无论该节点上是否运行了要访问的服务）时，您将被透明地路由到正在运行该服务的<code>worker</code>节点上。实际上，Docker充当您的群服务的负载均衡器（<code>load balancer</code>）。 默认情况下，使用<code>routing mesh</code>的服务以虚拟IP（VIP）模式运行。 即使在每个节点上运行的服务（通过<code>--mode global</code>）也使用路由网格。使用<code>routing mesh</code>时，无法保证哪个Docker节点响应客户端请求。要绕过路由网格，可以使用DNS循环（DNSRR）模式启动服务，方法是将<code>--endpoint-mode</code>标志设置为<code>dnsrr</code>。若使用<code>dnsrr</code>，需要在服务前运行自己的负载均衡器（常用的：有<code>nginx</code>、<code>HAproxy</code>）。通过DNS查询返回运行在<code>swarm</code>集群服务的所有节点的IP地址列表。</p><blockquote><p><code>routing mesh</code> 将外部请求路由到不同主机的容器，从而实现了外部网络对 <code>service</code> 的访问。</p></blockquote></li><li><p>分离控制流量和数据流量</p><p>默认情况下，与<code>swarm</code>管理相关的控制流量以及应用程序的数据流量都在同一网络上运行，尽管群集控制流量已加密。您可以将Docker配置为使用单独的网络接口来处理两种不同类型的流量。初始化或加入<code>swarm</code>时，每个节点（管理节点和工作节点）需要分别指定<code>--advertise-addr</code>和<code>--data-path-addr</code>。</p></li></ul><h4 id="创建用于独立容器使用的overlay网络"><a href="#创建用于独立容器使用的overlay网络" class="headerlink" title="创建用于独立容器使用的overlay网络"></a>创建用于独立容器使用的<code>overlay</code>网络</h4><ul><li><p>将独立容器连接到覆盖网络</p><p>在创建<code>ingress</code>网络时，若未指定<code>--attachable</code>（比如初始化<code>swarm</code>服务，或加入<code>swarm</code>时默认创建的<code>ingress</code>）意味着只有<code>swarm</code>服务可以使用它，独立运行的容器无法使用<code>ingress</code>。您可以将独立容器连接到使用–attachable标志创建的用户定义的覆盖网络。这使得在不同Docker守护程序上运行的独立容器能够进行通信，而无需在各个Docker守护程序主机上设置路由。</p></li></ul><ul><li><p>容器发现</p><p>在大多数情况下，您应该连接到服务名称，该名称是负载平衡的，并由支持该服务的所有容器（“tasks”）处理。要获取支持该服务的所有任务的列表，使用<code>DNS lookup</code> 查找<code>tasks.&lt;service-name&gt;</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;docker overlay&lt;/code&gt;网络用于创建多个docker主机之间的分布式网络。该网络位于（覆盖）特定于主机的网络之上，可以将&lt;code&gt;swarm&lt;/code&gt;集群服务和&lt;code&gt;containers&lt;/code&gt;容器与
      
    
    </summary>
    
      <category term="运维" scheme="http://172.104.32.215/categories/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="docker" scheme="http://172.104.32.215/categories/%E8%BF%90%E7%BB%B4/docker/"/>
    
    
      <category term="docker" scheme="http://172.104.32.215/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>python 多线程锁机制介绍</title>
    <link href="http://172.104.32.215/2019/03/21/python-mulit-thread/"/>
    <id>http://172.104.32.215/2019/03/21/python-mulit-thread/</id>
    <published>2019-03-21T15:56:07.000Z</published>
    <updated>2019-03-21T11:41:49.289Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><ul><li>说明：</li></ul><p>对共享内存（资源），进行加锁，释放锁。保证同一时间，只有一个线程对共享资源进行操作。即保证了对共享资源的原子操作。</p><ul><li>使用：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">_lock = threading.lock() # 定义锁 _local</span><br><span class="line"></span><br><span class="line">_lock.accquire()  # 获取锁</span><br><span class="line"># TODO do something</span><br><span class="line">do_somthing(share_var)   # 操作共享资源</span><br><span class="line">_lock.release()  #释放锁</span><br></pre></td></tr></table></figure><ul><li><p>缺点：</p><p>死锁</p><p>当有多个共享资源（比如：<code>R_A</code>, <code>R_B</code>），多个线程（比如：<code>T_A</code>, <code>T_B</code>），每个线程都需要操作共享资源。假如线程 <code>T_A</code> 已经获取了共享资源 <code>R_A</code>，<code>T_B</code> 获取了共享资源 <code>R_B</code> ， 而线程 <code>T_A</code> 等待 <code>T_B</code> 释放共享资源 <code>R_B</code> 。 同时，线程 <code>T_B</code> 等待 <code>T_A</code> 释放共享资源 <code>R_A</code> ，此时就陷入死锁状态。</p></li></ul><h3 id="RLock"><a href="#RLock" class="headerlink" title="RLock"></a>RLock</h3><ul><li><p>说明：</p><p>RLock 其实叫做“Reentrant Lock”，就是可以重复进入的锁，也叫做“递归锁”。这种锁对比 <code>Lock</code> 有是四个特点：</p><ol><li>谁获取谁释放。如果线程A获取锁，线程B无法释放这个锁，只有A可以释放；而 <code>Lock</code> 锁，可以被另外一个线程所释放。</li><li>同一线程可以多次获取到该锁，即可以acquire多次；</li><li>如果使用RLock，那么acquire和release必须成对出现。acquire多少次就必须release多少次，只有最后一次release才能改变RLock的状态为unlocked）</li><li>相对 <code>Rlock</code> ， <code>Lock</code> 速度更快。</li></ol></li><li><p>使用：</p><p>使用 <code>Rlock</code> 锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import threading  </span><br><span class="line">rLock = threading.RLock()  #RLock对象  </span><br><span class="line">rLock.acquire()  </span><br><span class="line">rLock.acquire() #在同一线程内，程序不会堵塞。  </span><br><span class="line">rLock.release()  </span><br><span class="line">rLock.release()</span><br></pre></td></tr></table></figure></li></ul><p>  使用 <code>Lock</code> 锁：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import threading  </span><br><span class="line">lock = threading.Lock() #Lock对象  </span><br><span class="line">lock.acquire()  </span><br><span class="line">lock.acquire()  #产生了死琐。  </span><br><span class="line">lock.release()  </span><br><span class="line">lock.release()</span><br></pre></td></tr></table></figure><ul><li>缺点：</li></ul><h3 id="semaphore（信号量）"><a href="#semaphore（信号量）" class="headerlink" title="semaphore（信号量）"></a>semaphore（信号量）</h3><ul><li><p>说明：</p><p>信号量是由操作系统管理的一个内部的数据结构，用于表示共享资源当前支持有多少并发线程进行操作。当信号量为<strong>负值</strong>时，那么所有想获取共享资源的线程被挂起，直到有线程释放信号量，信号量的值变成<strong>非负值</strong>时。</p><p>本质上，信号量就是一个计数器，当计数器的值为 <strong>非负值</strong> 时， 通知其他线程，可以对共享资源进行竞争。当计数器的值为 <strong>负值</strong> 时，所有待获取共享资源的线程挂起状态。</p></li></ul><ul><li><p>使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">semaphore = threading.Semaphore(0)</span><br><span class="line"></span><br><span class="line"># Thread1:</span><br><span class="line">def thread1_method():</span><br><span class="line">    semaphore.acquire()  # 线程1 对信号量进行获取操作</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Thread2:</span><br><span class="line">def thread2_method():</span><br><span class="line">  semaphore.release()  # 线程2 对信号量进行释放操作，可以提高计数器</span><br></pre></td></tr></table></figure></li></ul><p>  信号量的 release() 可以对计数器加 1 操作。然后通知其他的线程，如果信号量的计数器到了0，就会阻塞 acquire() 方法，直到得到另一个线程的release()操作，通知。如果信号量的计数器大于0，就会对这个值 -1 然后分配资源。</p><ul><li><p>缺点：</p><p>导致死锁</p><p>有多个线程（比如：<code>t1</code> ， <code>t2</code>），竞争多个信号量（比如：<code>s1</code> , <code>s2</code>）。 假如，现在有一个线程 <code>t1</code> 先等待信号量 <code>s1</code> ，然后等待信号量 <code>s2</code> ，而线程 <code>t2</code> 会先等待信号量 <code>s2</code> ，然后再等待信号量 <code>s1</code> ，这样就可能会发生死锁，导致 <code>t1</code> 等待 <code>s2</code> ，但是 <code>t2</code> 在等待 <code>s1</code> 。</p></li></ul><h3 id="Condition-条件同步"><a href="#Condition-条件同步" class="headerlink" title="Condition - 条件同步"></a>Condition - 条件同步</h3><ul><li><p>说明：</p><p>当多个线程<strong>等待</strong>同一个条件时，当条件发生的时候，会通知所有等待该条件的线程。比如生产者消费者里的例子：在消费者线程里，只要篮子（共享资源）不满（条件），消费者线程通知生产者线程可以操作该篮子（共享资源）；在生产者线程里，只要篮子不空（条件），生产者线程通知消费者线程可操作该篮子。</p></li><li><p>使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line">condition = threading.Condition()</span><br><span class="line"></span><br><span class="line">#  生产者</span><br><span class="line">def thread1_method():</span><br><span class="line">  condition.acquire()</span><br><span class="line">  # 条件判断</span><br><span class="line">  if (condition_var == False)：  # 条件不满足       </span><br><span class="line">      condition.wait()  # 释放锁，线程挂起，等待被其他线程唤醒</span><br><span class="line">  </span><br><span class="line">  # TODO do something</span><br><span class="line"></span><br><span class="line">  condition.notify()  # 条件满足，通知其他线程</span><br><span class="line">  condition.release()  # 释放资源</span><br><span class="line"></span><br><span class="line"># 消费者</span><br><span class="line">def thread2_method():</span><br><span class="line">   </span><br><span class="line">  condition.accquire()</span><br><span class="line">  # 条件判断</span><br><span class="line">  if (condition_var == False)：  # 条件不满足       </span><br><span class="line">       condition.wait()  # 释放锁，线程挂起，等待被其他线程唤醒</span><br><span class="line"></span><br><span class="line">  # 条件满足</span><br><span class="line">  # TODO  do something</span><br><span class="line"></span><br><span class="line">  condition.notify()  # 条件满足，通知其他线程</span><br><span class="line">  condition.release()   # 释放资源</span><br></pre></td></tr></table></figure><p><code>wait</code> 方法释放内部所占用的琐，同时线程被挂起，直至接收到通知被唤醒或超时（如果提供了timeout参数的话）。当线程被唤醒并重新占有琐的时候，程序才会继续执行下去。</p><p><code>notify</code> 唤醒一个挂起的线程（如果存在挂起的线程）。注意：<code>notify()</code>方法不会释放所占用的琐。需要通过 <code>release()</code> 方法释放锁。</p></li></ul><ul><li>缺点：</li></ul><h3 id="Event-事件"><a href="#Event-事件" class="headerlink" title="Event - 事件"></a>Event - 事件</h3><ul><li>说明：</li><li><p>使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">event = threading.Event()</span><br></pre></td></tr></table></figure></li><li><p>缺点：</p></li></ul><p><strong>参考：</strong></p><ul><li><p><a href="https://python-parallel-programmning-cookbook.readthedocs.io/zh_CN/latest/chapter2/index.html" target="_blank" rel="noopener">基于线程的并行</a></p></li><li><p><a href="https://stackoverflow.com/questions/22885775/what-is-the-difference-between-lock-and-rlock" target="_blank" rel="noopener">What is the difference between Lock and RLock</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Lock&quot;&gt;&lt;a href=&quot;#Lock&quot; class=&quot;headerlink&quot; title=&quot;Lock&quot;&gt;&lt;/a&gt;Lock&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;说明：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对共享内存（资源），进行加锁，释放锁。保证同一时间，只有一个线程对共享资源进
      
    
    </summary>
    
    
      <category term="Python" scheme="http://172.104.32.215/tags/Python/"/>
    
      <category term="thread" scheme="http://172.104.32.215/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>gcr.io和quay.io拉取镜像失败</title>
    <link href="http://172.104.32.215/2019/03/21/pull-docker-images-failed/"/>
    <id>http://172.104.32.215/2019/03/21/pull-docker-images-failed/</id>
    <published>2019-03-21T11:17:18.000Z</published>
    <updated>2019-03-21T11:41:49.289Z</updated>
    
    <content type="html"><![CDATA[<p>k8s在使用编排（manifest）工具进行yaml文件启动pod时，会遇到官方所给例子中<code>spec.containers.image</code>包含：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">quay.io/coreos/example_</span><br><span class="line">gcr.io/google_containers/example_</span><br></pre></td></tr></table></figure></p><p>也就是说，从quay.io和gcr.io进行镜像拉取，我们知道，国内访问外网是被屏蔽了的。可以将其替换为 quay-mirror.qiniu.com 和 registry.aliyuncs.com</p><ul><li><p>例如<br>  <strong>下拉镜像</strong>：<code>quay.io/coreos/flannel:v0.10.0-s390x</code><br>  如果拉取较慢，可以改为：<code>quay-mirror.qiniu.com/coreos/flannel:v0.10.0-s390x</code></p><p>  <strong>下拉镜像</strong>：<code>gcr.io/google_containers/kube-proxy</code><br>  可以改为： <code>registry.aliyuncs.com/google_containers/kube-proxy</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;k8s在使用编排（manifest）工具进行yaml文件启动pod时，会遇到官方所给例子中&lt;code&gt;spec.containers.image&lt;/code&gt;包含：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
      <category term="运维" scheme="http://172.104.32.215/categories/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="docker" scheme="http://172.104.32.215/categories/%E8%BF%90%E7%BB%B4/docker/"/>
    
    
      <category term="docker" scheme="http://172.104.32.215/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker存储原理——介绍</title>
    <link href="http://172.104.32.215/2019/03/21/docker-storage/"/>
    <id>http://172.104.32.215/2019/03/21/docker-storage/</id>
    <published>2019-03-21T08:46:02.000Z</published>
    <updated>2019-03-21T12:19:28.918Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker数据存储"><a href="#Docker数据存储" class="headerlink" title="Docker数据存储"></a>Docker数据存储</h2><blockquote><p>在Docker中，有两种方式对数据进行存储：<code>docker volume</code>(存储卷) 和 <code>docker storage driver</code>（存储驱动），本文主要介绍<code>docker storage driver</code>存储驱动。</p></blockquote><p>准备工作：</p><p>OS: centos 7.4 (kernel version &gt; 3.10.514 )</p><p>Docker: docker-ce 18.03.1 ( <a href="http://www.weshzhu.com/2019/01/03/binary-install-docker-ce-on-centos7/" target="_blank" rel="noopener">docker-ce安装教程</a>)</p><h4 id="Docker-数据存储"><a href="#Docker-数据存储" class="headerlink" title="Docker 数据存储"></a>Docker 数据存储</h4><p>在了解<code>Docker storage driver</code>之前，我们先了解一下Docker如何存储容器数据和镜像数据。在Docker中数据分为镜像数据和容器数据，容器数据又包含容器可写层和<code>docker volume</code>存储。镜像数据是一种静态数据，存储了提供容器运行的程序、配置文件等。容器数据可以理解为动态 + 静态的数据（阅读本文后，可能有比较直观的理解），供容器运行使用。</p><p>   <img src="/images/container-layers.jpg" alt></p><p>如上图所示，容器层（high-level）是非常小的层，允许程序对该层读写操作；镜像层(low-level)包含了大部分的数据，并且是只读的。在镜像未启动时均是以镜像层存储在host主机上（存储路径：<code>/var/lib/docker/&lt;storage-driver&gt;/</code>）。以该镜像为基础，通过<code>docker run</code>启动一个或多个容器后，针对每个启动的容器会增加一层——可读写层（容器层）。</p><ul><li><p>镜像层<br>Docker镜像是由一系列的层（<code>layer</code>）构成，镜像的每个<code>layer</code>对应这个Dockerfile中的每条指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:15.04</span><br><span class="line">COPY . /app</span><br><span class="line">RUN mkdir -p /app/conf/</span><br><span class="line">CMD python /app/app.py</span><br></pre></td></tr></table></figure><p>通过<code>docker build -t</code>命令构建镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t my-ubuntu:test -f Dockerfile .</span><br><span class="line">  </span><br><span class="line">  Sending build context to Docker daemon  3.584kB</span><br><span class="line">  Step 1/4 : FROM ubuntu:15.04</span><br><span class="line">  ---&gt; d1b55fd07600</span><br><span class="line">  Step 2/4 : COPY . /app</span><br><span class="line">  ---&gt; 6e3fe23e82f3</span><br><span class="line">  Step 3/4 : RUN mkdir -p /app/conf/</span><br><span class="line">  ---&gt; Running in 3a9b550d957b</span><br><span class="line">  Removing intermediate container 3a9b550d957b</span><br><span class="line">  ---&gt; 038a1543c273</span><br><span class="line">  Step 4/4 : CMD python /app/app.py</span><br><span class="line">  ---&gt; Running in 9b56a922b87f</span><br><span class="line">  Removing intermediate container 9b56a922b87f</span><br><span class="line">  ---&gt; 58866642a2af</span><br><span class="line">  Successfully built 58866642a2af</span><br><span class="line">  Successfully tagged my-ubuntu:test</span><br></pre></td></tr></table></figure><p>查看镜像是否存在：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">  REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">  my-ubuntu           test                58866642a2af        5 minutes ago       131MB</span><br><span class="line">  ubuntu              15.04               d1b55fd07600        2 years ago         131MB</span><br></pre></td></tr></table></figure><p>查看镜像构建详情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker history 58866642a2af</span><br><span class="line">  </span><br><span class="line">  IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">58866642a2af        49 seconds ago      /bin/sh -c #(nop)     CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;pyth…   0B                  </span><br><span class="line">038a1543c273        51 seconds ago      /bin/sh -c mkdir -p    /app/conf/                  0B                  </span><br><span class="line">6e3fe23e82f3        53 seconds ago      /bin/sh -c #(nop)    COPY dir:3f69c750361eacc36…   101B                </span><br><span class="line">d1b55fd07600        2 years ago         /bin/sh -c #(nop)    CMD [&quot;/bin/bash&quot;]             0B                  </span><br><span class="line">&lt;missing&gt;           2 years ago         /bin/sh -c sed -i    &apos;s/^#\s*\(deb.*universe\)$…   1.88kB              </span><br><span class="line">&lt;missing&gt;           2 years ago         /bin/sh -c echo    &apos;#!/bin/sh&apos; &gt; /usr/sbin/poli…   701B                </span><br><span class="line">&lt;missing&gt;           2 years ago         /bin/sh -c #(nop)    ADD file:3f4708cf445dc1b53…   131MB</span><br></pre></td></tr></table></figure><p>我们看到<code>58866642a2af</code> <code>038a1543c273</code> <code>6e3fe23e82f3</code> 是刚刚创建的层，对应着Dockerfile文件中的每条指令。<code>d1b55fd07600</code>是基础镜像的层，而<code>missing</code>则是以往他人在其他主机上构建的层，可以忽视。</p><p>当您使用<code>docker pull</code>从<code>registry</code>（镜像仓库）中下拉镜像时，每个镜像层都会单独下拉，并存储在Docker所在host的文件系统中，Linux主机上通常是<code>/var/lib/docker</code>。您可以在此示例中看到这些镜像层被拉出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull ubuntu:15.04</span><br><span class="line">  15.04: Pulling from library/ubuntu</span><br><span class="line">  9502adfba7f1: Pull complete </span><br><span class="line">  4332ffb06e4b: Pull complete </span><br><span class="line">  2f937cc07b5f: Pull complete </span><br><span class="line">  a3ed95caeb02: Pull complete </span><br><span class="line">  Digest:      sha256:2fb27e433b3ecccea2a14e794875b086711f5d49953ef173d8a03e8707f1510   f</span><br><span class="line">  Status: Downloaded newer image for ubuntu:15.04</span><br></pre></td></tr></table></figure><p>下拉的镜像层存储在<code>/var/lib/docker/&lt;storage-driver&gt;/</code>目录中，本例使用的存储驱动是<code>overlay2</code>，Docker version &gt; 1.10的版本，每层的目录名称与图层ID不对应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /var/lib/docker/overlay2/</span><br><span class="line">  drwx------. 4 root root     55 Jan 12 10:19    1e72c036bc24730abff4e3eed803c5d9c3ba67d61cc4dc0da62e880a5b23d7a9</span><br><span class="line">  drwx------. 4 root root     55 Jan 12 10:14      1fd044fc33c05db1b7fddf37992788befb6e5bd5dfa6ab0f4a72f281d68b5d8c</span><br><span class="line">  drwx------. 4 root root     55 Jan 12 10:20      2205c9e9efbd435b968dba2beb2390e2ddc49b5cd4efedae5a6a08a5a6d2634b</span><br><span class="line">  drwx------. 4 root root     55 Jan 12 10:18      25e720a5f2d95330556d5f99268217045654002d0c47cc77342342c2ba4af226</span><br><span class="line">  drwx------. 4 root root     55 Jan 12 10:18      277b95e43bbeb2f13ec6b7dd636b774d5e9ea56bad1414c6f1fe6c3178970172</span><br></pre></td></tr></table></figure></li><li><p>容器层</p><p>容器和镜像之间的主要区别在于顶部可写层，所有对容器的操作：对文件的修改和添加，都是在可写层进行操作的（写时复制CoW策略），<code>low-level</code>的镜像层不会更改。若将启动的容器进行删除，那么所有的操作将不被保留。<br>若以同一个镜像启动多个容器，则底层的镜像层是公共的层，为所有容器共用，对应每个容器有各自的可写层。对容器文件的修改保存均在容器层。对于不同的容器，容器层的数据不可共享，若想共享数据，可采用<code>docker volume</code>存储。针对该存储方案，由于内容较多，将单独作为一个章节进行介绍。</p><p><img src="/images/sharing-layers.jpg" alt></p><p>当启动一个容器，启动容器时，会在容器层的顶部添加一个体积比较小的可写容器层。容器对文件系统所做的任何更改都存储在此处。Docker的host主机文件系统中对应的容器层存储路径<code>/var/lib/docker/containers</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /var/lib/docker/containers</span><br><span class="line">drwx------. 4 root root 165 Jan 12 10:25    025030ca0a6d5383346d4cf5471108e5cfad22d74c3411a606baf3a902c99a28</span><br><span class="line">drwx------. 4 root root 165 Jan 12 10:26    0a19a162a971fb9364907e9d2e8d39baf47d588d9e18fc6c47f16f4bca56d569</span><br><span class="line">drwx------. 4 root root 237 Jan 12 10:25    1058890a8138eafaf5b7d84d3d708c0169fcba024e27697c01952465d0fdb78a</span><br><span class="line">drwx------. 4 root root 165 Jan 12 10:25    152da522924bf4ebebf960c3f93897f7d582f53ba98239922bf56baec7876eea</span><br><span class="line">drwx------. 4 root root 165 Jan 12 10:25    1ee87d5bc8e9a58d137cbe3f98e5fd85c7ac360e03de77d69e5fa27d315fb509</span><br></pre></td></tr></table></figure></li></ul><h4 id="写时复制（CoW）策略"><a href="#写时复制（CoW）策略" class="headerlink" title="写时复制（CoW）策略"></a>写时复制（CoW）策略</h4><p>写时复制（CoW）是一种共享和复制文件的策略。如果要读取或要修改的文件或目录存在于镜像中的<code>low-level</code>层（镜像层），若对该文件进行读访问，则它只需使用镜像层中的现有文件。 如果第一次添加或修改此文件时（比如：构建镜像或运行容器时），文件将被复制到该容器层（可写层）并进行修改。容器未更改的任何文件都不会复制到此可写层，意味着可写层尽可能小。这种策略保证了容器文件系统以及I/O操作的最小化。</p><p>对于aufs，overlay和overlay2存储驱动，写时复制操作遵循以下顺序：</p><ol><li>在镜像层中搜索要修改的文件。该过程从最新层开始，一次一层地向下移动到基础镜像层。找到结果后，会将它们复制到缓存中以加快将来的操作。</li><li><code>copy_up</code>对找到的文件的第一个副本执行操作，以将文件复制到容器的可写层。</li><li>对此文件副本进行任何修改，将保存在容器层，后续的操作将值针对该副本进行，对于镜像层的该文件对于容器来说，是不可见的。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Docker数据存储&quot;&gt;&lt;a href=&quot;#Docker数据存储&quot; class=&quot;headerlink&quot; title=&quot;Docker数据存储&quot;&gt;&lt;/a&gt;Docker数据存储&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在Docker中，有两种方式对数据进行存储：&lt;co
      
    
    </summary>
    
      <category term="运维" scheme="http://172.104.32.215/categories/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="docker" scheme="http://172.104.32.215/categories/%E8%BF%90%E7%BB%B4/docker/"/>
    
    
      <category term="docker" scheme="http://172.104.32.215/tags/docker/"/>
    
      <category term="storage" scheme="http://172.104.32.215/tags/storage/"/>
    
  </entry>
  
  <entry>
    <title>Docker中启动jenkins容器，并在jenkins中使用docker 命令，解决docker command not found</title>
    <link href="http://172.104.32.215/2018/03/22/jenkins-docker-command-not-found/"/>
    <id>http://172.104.32.215/2018/03/22/jenkins-docker-command-not-found/</id>
    <published>2018-03-21T20:04:07.000Z</published>
    <updated>2019-03-21T12:13:00.218Z</updated>
    
    <content type="html"><![CDATA[<p>首先，制作支持docker的jenkins镜像，基础镜像是<code>jenkins:2.60.3</code><br>参考<a href="https://container-solutions.com/running-docker-in-jenkins-in-docker/" target="_blank" rel="noopener">Running Docker in Jenkins (in Docker)</a></p><p>编辑Dockerfile，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM jenkins:2.60.3</span><br><span class="line"></span><br><span class="line">USER root</span><br><span class="line">RUN echo &apos;&apos; &gt; /etc/apt/sources.list.d/jessie-backports.list \</span><br><span class="line">  &amp;&amp; echo &quot;deb http://mirrors.aliyun.com/debian jessie main contrib non-free&quot; &gt; /etc/apt/sources.list \</span><br><span class="line">  &amp;&amp; echo &quot;deb http://mirrors.aliyun.com/debian jessie-updates main contrib non-free&quot; &gt;&gt; /etc/apt/sources.list \</span><br><span class="line">  &amp;&amp; echo &quot;deb http://mirrors.aliyun.com/debian-security jessie/updates main contrib non-free&quot; &gt;&gt; /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">RUN apt-get update       &amp;&amp; apt-get install -y sudo       &amp;&amp; apt-get install -y libltdl7       &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">RUN echo &quot;jenkins ALL=NOPASSWD: ALL&quot; &gt;&gt; /etc/sudoers</span><br><span class="line"></span><br><span class="line">USER jenkins</span><br><span class="line">COPY plugins.txt /usr/share/jenkins/plugins.txt</span><br><span class="line">RUN /usr/local/bin/plugins.sh /usr/share/jenkins/plugins.txt</span><br></pre></td></tr></table></figure></p><p>出现在执行docker命令时报：<code>docker: error while loading shared libraries: libltdl.so.7: cannot open shared object file: No such file or directory</code>错误<a href="https://www.cnblogs.com/leolztang/p/6934694.html" target="_blank" rel="noopener">解决办法，参考</a><br>加入如下代码后，问题解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RUN echo &apos;&apos; &gt; /etc/apt/sources.list.d/jessie-backports.list \</span><br><span class="line">  &amp;&amp; echo &quot;deb http://mirrors.aliyun.com/debian jessie main contrib non-free&quot; &gt; /etc/apt/sources.list \</span><br><span class="line">  &amp;&amp; echo &quot;deb http://mirrors.aliyun.com/debian jessie-updates main contrib non-free&quot; &gt;&gt; /etc/apt/sources.list \</span><br><span class="line">  &amp;&amp; echo &quot;deb http://mirrors.aliyun.com/debian-security jessie/updates main contrib non-free&quot; &gt;&gt; /etc/apt/sources.list</span><br></pre></td></tr></table></figure></p><p>预先安装的插件，放入plugins.txt文件中，也可以部署jenkins后，手动安装插件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">scm-api:latest</span><br><span class="line">git-client:latest</span><br><span class="line">git:latest</span><br><span class="line">greenballs:latest</span><br></pre></td></tr></table></figure></p><p>启动jenkins容器，执行如下命令，启动jenkins容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -v /var/run/docker.sock:/var/run/docker.sock -v $(which docker):/usr/bin/docker -v $PWD:/var/jenkins_home -p 8080:8080 jenkins:v2.6</span><br></pre></td></tr></table></figure><p>注意挂载<code>-v /var/run/docker.sock:/var/run/docker.sock -v $(which docker):/usr/bin/docker</code>，才可以共享宿主机的docker资源<br>指定工作目录：<code>-v $PWD:/var/jenkins_home</code>，将当前目录作为jenkins的工作目录。<br>此时，可以通过ip:8080端口访问jenkins，按照提示一步一步进行。配置完后，就可以使用了。<br>首先，我们新建一个pipeline构建计划，Jenkinsfile内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&apos;Test&apos;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &apos;docker images&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>，执行立即构建，当执行pipeline中的<code>docker images</code>命令时，报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ docker images</span><br><span class="line">Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.37/images/json: dial unix /var/run/docker.sock: connect: permission denied</span><br></pre></td></tr></table></figure></p><p>这是jenkinsfile中的命令在访问宿主机的<code>unix:///var/run/docker.sock</code>守护进程时，权限不足。在jenkins中，执行pipeline的用户是jenkins，可以在pipelines中的docker命令前增加<code>sudo</code>，便成功执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[test_pipeline] Running shell script</span><br><span class="line">+ sudo docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">jenkins             v2.6.3              7c6cba7c8a03        18 minutes ago      705MB</span><br><span class="line">jenkins             v2.6                bb042102b598        3 hours ago         705MB</span><br><span class="line">jenkins             2.60.3              cd14cecfdb3a        2 days ago          696MB</span><br><span class="line">busybox             latest              22c2dd5ee85d        3 days ago          1.16MB</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先，制作支持docker的jenkins镜像，基础镜像是&lt;code&gt;jenkins:2.60.3&lt;/code&gt;&lt;br&gt;参考&lt;a href=&quot;https://container-solutions.com/running-docker-in-jenkins-in-docke
      
    
    </summary>
    
      <category term="运维" scheme="http://172.104.32.215/categories/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="docker" scheme="http://172.104.32.215/categories/%E8%BF%90%E7%BB%B4/docker/"/>
    
    
      <category term="docker" scheme="http://172.104.32.215/tags/docker/"/>
    
      <category term="jenkins" scheme="http://172.104.32.215/tags/jenkins/"/>
    
  </entry>
  
</feed>
