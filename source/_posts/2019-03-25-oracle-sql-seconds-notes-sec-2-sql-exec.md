---
title: 精通Oracle SQL（第二版）读书笔记  -  第二章 SQL执行
date: 2017-08-17 13:58:59
tags:
  - Oracle
categories:
  - Oracle
---

# 精通Oracle SQL（第二版）读书笔记
## 第二章 SQL执行
### 数据库和数据库文件、实例等概念
> **数据库** 归属于 数据库文件

> **实  例** 归属于内存结构，是由SGA(System Global Area)及一系列后台进程组成的。

> **PGA** 客户端进程是与服务器进程相关联的，每个服务器进程都会被分配一块私有的内存区域，称为程序共享区域或进程共享内存区域（Process Global Area）。

> **SGA** 包含共享池（库高速缓存）、数据库高速缓存。

### SGA
###### 共享池
1. 存储解析后的SQL语句，不管有多少个用户想执行同样的SQL语句，Oracle都会只解析该语句一次，将其放在共享池中，共享。
2. Oracle 使用的系统参数，在一块被称为数据字典的区域。
###### 高速缓存区域
- 存储所有的数据库对象信息。

###### 管理共享池：
- 共享池的内存大小是由限制的，需要通过最近最少使用（LRU）算法进行共享池内存的管理，即保留那些使用频繁以及最近使用的解析语句。

### 执行SQL语句 

![执行SQL语句](http://img.blog.csdn.net/20170331085505286?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenNkNDk4NTM3ODA2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


### 绑定变量 
-  在SQL语句中，有时使用**绑定变量**比使用常量更节约SQL语句执行时间，因为:在使用了绑定变量时，即使改变了变量的值，Oracle还是可以使用共享池的该SQL语句。

>    SQL> varible v_dept number  #定义变量 v_dept 为 number 类型
	
>	 SQL> exec : v_dept = 10

>    SQL> SELECT * FROM employees WHERE departent_id = :v_dept;    
### 锁存器
- 锁存器是为了Oracle读取存在库高速还粗或者其他内存结构中的信息时必须获得的一种锁，其他回话必须等待，锁存器是串行的。
### 互斥锁
- 一个序列化组件，阻止多个线程同时访问一个共享结构，与锁存器相比，互斥锁的优点：

      **1.** 占内存少，且可快速获取和释放；

      **2.** 可直接修改游标的互斥锁引用计数，避免为已经打开的游标获取库高速缓存锁。
### SGA缓冲区缓存
![SGA缓冲区缓存](http://img.blog.csdn.net/20170331085311877?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenNkNDk4NTM3ODA2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

- **块:** Oracle进行操作的最小单位。典型的块大小：4KB，8KB，16KB；这取决于操作系统。

- **缓冲区缓存**

![SGA缓冲区缓存空间管理](http://img.blog.csdn.net/20170331085413757?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenNkNDk4NTM3ODA2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

- 刷新（清空）共享池和缓冲区缓存
> SQL> alter system flush buffer_cache;

> SQL> alter system flush shared_pool;

- 硬解析的物理存取和软解析的逻辑读取，我们的目标是开发出能够更多重用共享池和缓冲区缓存中信息的代码。

### 查询转换
- 在查询通过了语法和权限的检查之后，查询就进入了转换为一系列的查询块的转换阶段（SELECT 关键字定义查询块）。
- 查询块嵌套在另一个查询块中或者以某种方式与另一个查询块相连结。查询转换的目的是确定如果改变查询的写法会不会提供更好的查询计划。
##### 查询块
- 查询块可以由 Oracle 自动生成系统名称，也可以通过 **QB_NAME** 提示命名。
- 可以在**V$SQL_PLAN**视图中查询所使用的查询块名称，即之前执行的 SQL 语句。
##### 视图合并 —— 类型转换
- 视图合并是一种能将内嵌或存储式视图展开为能够独立分析或者与查询剩余部分合并成总体执行计划的独立查询块的转换。
- 阻止视图合并的情况：查询块中包含分析函数、聚合函数、集合运算（例：UNION 、 INTERSECT 、MINUS）、ORDER BY 子句或使用了ROWNUM。（但可以使用MERGE 提示来强制执行视图合并）
##### 子嵌套解嵌套—— 类型转换
- 子查询解嵌套与视图合并的相似之处在于子查询也是通过一个单独的查询块来表示的，它们的区别：位置不同，子查询位于WHERE 子句，由转换器执行的解嵌套审查。最典型的转换就是将子查询转换为表联接。
##### 联结消除 —— 类型转换
- Oracle 消除冗余表的两种情况
  1. 存在主 —— 外键约束
  2. 外联接，即使没有任何主 —— 外键约束，如果想消除的表在联结列上具有唯一键约束，并且没有任何列出现在查询列表中，则这张表也是可以消除的。
- 如果一张表没有出现在执行计划中，就是发生了联结消除转换。
- 限制
  1. 如果在查询的任何地方引用了联结键，则不支持联结消除；
  2. 如果主外键约束包含多个列，则不支持联结消除。
##### 排序消除 —— 类型转换
- 与联结消除类似，排序消除也会移除不必要的运算，在这里不必要的运算就是排序。
- 优化器选择使用在 ORDEY BY 子句的列上的索引，因为索引本事就是按照排序后的顺序存储的，此时，会发生类似的类型转换。
##### 谓词推进（谓语即所谓的条件）
- 谓词推进就是将谓词从一个内含查询块中应用到不可合并的查询块中，目的是允许索引的使用或让其他数据集筛选能够在查询中尽早的进行。
- 如果可以将谓词推进到不可合并查询块中尽早的执行，再剩下的执行计划中所需要抓取的数据就会更少。
##### 使用物化视图进行查询重写
- 查询重写的前提是某个查询被保存为物化视图。转换器重写该查询以使用预先计算好的物化视图数据而不需要执行当前查询的转换。
- 物化视图与普通视图的区别是：查询已经执行，并将查询结果保存在了一张表中。也就是说，所有的确定执行计划、执行查询以及收集所有数据的工作已经完成，当同样的查询再次发起时就不需要再做一遍了。

##### 确定执行计划
- 执行计划定义：就是Oracle访问查询所使用的对象并返回相应结果数据将会采用的一系列的步骤。
